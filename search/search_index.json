{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome","title":"Welcome","text":"<p>The Production Flow Description Language (PFDL) is a domain specific language for the description of production orders in the manufacturing of the future. With the help of the PFDL customized products and their production steps can be described. This documentation describes the PFDL itself and the PFDL Scheduler, a software which makes use of the language itself to schedule Tasks and Services. </p> <p>For an overview about the concepts and architecture of the PFDL and its Scheduler visit Getting Started. Here you will be guided through the first steps of installation and the execution of a simple example file.</p> <p>The PFDL section contains an introduction to the language itself. It can also be used as a reference while developing PFDL files.</p> <p>If you want to use the Scheduler to parse your PFDL files and integrate it into your software, refer to the Scheduler Reference section.</p> <p>Last but not least there are the examples. These can be used to better understand the concepts of the language and to show some advanced usecases that can be modeled with the language.</p>"},{"location":"examples/concurrency_and_synchronization/","title":"Concurrency and Synchronization","text":""},{"location":"examples/concurrency_and_synchronization/#concurrency-and-synchronization","title":"Concurrency and Synchronization","text":"<p>As already stated in the parallel section, there is no keyword for the synchronization. The next statement after a parallel block is only started if all concurrently running tasks are finished.</p> <p>The following example demonstrates the use of the parallel keyword and the implicit synchronization.</p> <pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct SheetPart\n    width: number\n    length: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask productionTask\n    # Execute paintingTask and cuttingTask in Parallel\n    Parallel\n        paintingTask\n        cuttingTask\n\n    # gets started when paintingTask and cuttingTask are finished\n    paintingTask\nEnd\n\nTask paintingTask\n    Painting\n        In\n            Color\n                {\n                    \"name\": \"green\",\n                    \"rgb\": [0, 255, 0]\n                }\n        Out\n            pr: PaintResult\nEnd\n\nTask cuttingTask\n    Cutting\n        Out\n            cr: CuttingResult\nEnd\n</code></pre>"},{"location":"examples/control_structures/","title":"Control Structures","text":""},{"location":"examples/control_structures/#control-structures","title":"Control structures","text":""},{"location":"examples/control_structures/#condition","title":"Condition","text":"<pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct SheetPart\n    width: number\n    hight: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask productionTask\n   Painting\n        In\n            Color \n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        Out\n            pr: PaintingResult\n\n    Condition\n        pr.wetness &gt; 10\n    Passed\n        Drying\n            In\n                pr\nEnd\n</code></pre>"},{"location":"examples/control_structures/#counting-loop","title":"Counting loop","text":"<pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct SheetPart\n    width: number\n    hight: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask productionTask\n    Cutting\n        Out\n            cr: CuttingResult\n    Loop i To cr.parts_count\n        Milling\n            cr.sheet_parts[i]\nEnd\n</code></pre>"},{"location":"examples/control_structures/#while-loop","title":"While loop","text":"<pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nTask productionTask\n    Painting\n        In\n            Color \n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        Out\n            pr: PaintingResult\n\n    Loop While pr.wetness &gt; 10\n        Drying\n            In\n                pr\n            Out\n                pr: PaintingResult\nEnd\n</code></pre>"},{"location":"examples/introduction/","title":"Introduction","text":""},{"location":"examples/introduction/#introduction","title":"Introduction","text":"<p>In this section complete PFDL programs are presented to give a better understanding. These examples can be used as a starting point for your own PFDL programs after you have read the PFDL section of this documentation.</p>"},{"location":"examples/task_input_and_output/","title":"Task input and output","text":""},{"location":"examples/task_input_and_output/#task-input-and-output","title":"Task input and output","text":"<p>Tasks can define an Input and an Output to pass data when calling each other. The following examples demonstrate both cases.</p>"},{"location":"examples/task_input_and_output/#task-input","title":"Task input","text":"<p>In this example the Task <code>paintingTask</code> calls the Service <code>Painting</code> which returns a <code>PaintingResult</code>. The other Task <code>cuttingTask</code> calls a Service <code>Cutting</code> which needs a <code>PaintingResult</code> as input. To pass the variable <code>pr</code> from one Task to the other, <code>cuttingTask</code> defines in lines 41-42 a possible input. This Task is called in the lines 35-37 by the <code>paintingTask</code> with parameter <code>pr</code>.</p> <pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct SheetPart\n    width: number\n    hight: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask productionTask\n    paintingTask\nEnd\n\nTask paintingTask\n    Painting\n        In\n            Color\n                {\n                    \"name\": \"green\",\n                    \"rgb\": [0, 255, 0]\n                }\n        Out\n            pr: PaintingResult\n\n    cuttingTask\n        In\n            pr\nEnd\n\nTask cuttingTask\n    In\n        pr: PaintingResult\n\n    Cutting\n        In\n            pr\n        Out\n            cr: CuttingResult\nEnd\n</code></pre>"},{"location":"examples/task_input_and_output/#task-output","title":"Task output","text":"<pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct SheetPart\n    width: number\n    hight: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask productionTask\n    cuttingTask\nEnd\n\n# cuttingTask calls paintingTask and uses the output in Cutting\nTask cuttingTask\n    paintingTask\n        Out\n            pr: PaintResult\n\n    Cutting\n        In\n            pr\n        Out\n            cr: CuttingResult\nEnd\n\nTask paintingTask\n    Painting\n        In\n            Color\n                {\n                    \"name\": \"green\",\n                    \"saturation\": 5,\n                    \"rgb\": [0, 255, 0]\n                }\n        Out\n            pr: PaintingResult\n\n    Out\n        pr\nEnd\n</code></pre>"},{"location":"getting_started/architecture/","title":"Architecture","text":""},{"location":"getting_started/architecture/#architecture","title":"Architecture","text":"<p>The next sections are both for users of the PFDL Scheduler and for those who want to work on the Scheduler itself. Thus, in the following the basic architecture of the Scheduler will be explained as well as things like the CI/CD pipeline. If you just want to look up terms used in this docu refer to the Glossary.</p> <p>To better understand the architecture of the PFDL and its scheduler we will explain the main concepts and systems in the following. The overall architecture consisting of the PFDL Scheduler and a so called Execution Engine (EE) is depicted in the figure below. The EE is developed in parallel to the Scheduler and is used for direct control of the Field Devices on the factory floor.</p> Fig.1: An overview of the PFDL architecture. A PFDL file serves as the input for the Scheduler which processes it and transforms it in an internal representation. This is used to interact with the execution engines."},{"location":"getting_started/architecture/#parsing","title":"Parsing","text":"<p>The PFDL file is the input for the PFDL interpreter, which consists of the Lexer and Parser. The grammar of the PFDL is implemented with ANTLR and the Lexer and Parser are generated from the ANTLR grammar specification files.</p> <p>The generated parse tree from the Parser serves as input to the Visitor which traverses the given tree and generates the PFDL domain model from it. A shortened UML class diagram of the domain model is shown in the figure below.</p>"},{"location":"getting_started/architecture/#model-creation-and-validation","title":"Model creation and validation","text":"Fig.2: The domain model of PFDL files. The main class is the Process class which represents the production process described by the PFDL file.   <p>This model can be checked for static semantic errors (errors that were not found while parsing) by the Semantic Validation unit.</p>"},{"location":"getting_started/architecture/#petri-net-generation-an-execution","title":"Petri Net generation an execution","text":"<p>If the validation is passed the model gets converted into a Petri Net by the Petri Net Generator. This structure represents the production order as a formal description. Note that the transformation into a Petri Net is only one of many possible ways to transform the model.</p> <p>The scheduler provides interfaces for interaction with the Petri net. The Petri Net Logic unit takes care of the evaluation of the petri net and the firing of events into it. You can register callback functions which will be called when specific states in the net are reached (e.g: a specific service has started or finished). It is also possible to pass Events to the Scheduler, e.g. when a service finished its execution. The net will then evaluate its state and call the corresponding callback functions for the new state.</p>"},{"location":"getting_started/architecture/#dashboard-connection","title":"Dashboard Connection","text":"<p>It is possible to connect the Scheduler with a Dashboard. This will add the corresponding Production Order to the Dashboard when the Scheduler is started. Now, all updates of the order are visualized in real time.</p> <p>To enable this functionality, an address to the dashboard can be passed to the <code>Scheduler</code> class. If such an address is given, the Scheduler will send log messages (e.g. Task started, Service finished, ...), Petri Net updates, and order updates to the corresponding address. You can, however, also send messages to the dashboard from outside of the scheduler. The API specification can be found in the Dashboard API section. Note: Currently, our Dashboard is not open source, but you could also write your own visualization if you stick to the API specification.</p>"},{"location":"getting_started/architecture/#execution-engine","title":"Execution Engine","text":"<p>The Execution Engine (EE) provides an interface that connects the PFDL Scheduler to the Field Level Devices. Our approach implements the EE as an OPC UA Server, however, the concept of the EE is not OPC UA specific and can be transferred to different implementation approaches. Since the Scheduler works with a petri net at the moment, the EE is launched with the start of the petri net execution, executes the scheduled services on the field level and is shut down as soon as the petri net reaches its last place. In this context, the EE offers several functionalities: Besides providing an interface to both, the field level resources and the PFDL Scheduler, it features a Data Lifecycle Object that handles the data management during the petri net execution. As the PFDL allows to define task specific variables, condition blocks based on runtime data, as well as input and output variables for services, the Data Lifecycle Object enriches the defined variables from the PFDL with the runtime data received from the Field Level. In consequence, the PFDL Scheduler is able to access this data by requesting it from the Data Lifecycle Object. Lastly the EE contains a functionality to assign services to resources in case of several resources offering identical services.</p> <p>The Execution Engine - PFDL Scheduler interface is based upon callback functions that are provided by the PFDL Scheduler. From these callbacks, the EE receives information about the tasks and services that are currently scheduled. Besides, it enables the Execution Engine to initiate transitions of the Petri Net by placing tokens in it. As the Execution Engine contains the runtime data from a Petri Net Execution, the Execution Engine - PFDL Scheduler interface enables the Scheduler to access this data. </p> <p>The Execution Engine \u2013 Device Interface enables the communication between the Execution Engine and Field Level Devices and ultimately facilitates the execution of Services that are scheduled by the PFDL Scheduler. This Communication is not bound to any communication protocol, but can feature different protocols. As our approach to the Execution Engine is implemented as an OPC UA Server, we use OPC UA Clients to communicate with Field Level Devices. However, other communication protocols, such as MQTT, can be implemented.</p>"},{"location":"getting_started/architecture/#data-lifecycle-object","title":"Data Lifecycle Object","text":"<p>The Data Lifecycle Object manages the runtime data that is required during the execution of one PFDL file. It is dynamic, which allows variables and tasks defined in the PFDL to be instantiated, updated and deleted during runtime. As soon as a task is started, it is added as a task object to the data lifecycle object. Since tasks are nested, each new task provides a task context which identifies the location of this task in the Data Lifecycle structure. With these context references, the data lifecycle object aggregates a tree of tasks, whose root is the production task. Each new added task object either extends an existing branch of task objects or creates a new one. </p> <p>To declare task specific variables, data types for all Structs, which are defined within a PFDL file, have to be added to the Execution Engine. In addition, these data types are used for the parameterization of a service. As soon as a variable appears in a PFDL task, the data lifecycle object uses the corresponding data type to instantiate the variable. Once instantiated, the variable values are updated in accordance to the Petri Net execution. In general, two different levels of variable declaration have to be distinguished. First, there are variables that are defined on the level of the production task. These variables exist while the execution of the Petri Net is in progress. One instantiated, their values are only updated and they will never be deleted. Second, there are variables that are defined on levels atop of the production task. These variables are the input for concrete services or other tasks and disappear from the data lifecycle object after the completion of the task, which instantiates them. Before deletion, they can consign their values to a task on the aggregation level below.</p>"},{"location":"getting_started/architecture/#field-level-devices","title":"Field Level Devices","text":"<p>The Field level constitutes the lowest level of the automation pyramid and captures all kind of devices that are found in industrial manufacturing systems. These devices are either sensors or actors and directly influence processes by measuring data or performing an arbitrary step of a manufacturing process.</p>"},{"location":"getting_started/ci_cd/","title":"CI/CD","text":""},{"location":"getting_started/ci_cd/#ci-cd-pipeline","title":"CI / CD Pipeline","text":"<p>The CI/CD  pipeline consists of three stages: Test, Coverage and Deploy. In the Test stage unit and integrations tests and a lint check are executed. Due to a high test coverage we make sure that all PFDL programs will be parsed correctly and the scheduler works as he should. With the Linter we check for coding guideline violations and assure that the code satisfies them to a certain degree. If all tests are passed the coverge stage measures the code coverage of the unit and integration tests and creates an detailed report about it. Last but not least the deploy stage starts where the documentation and the code is build.</p> <p>This pipeline starts on every push to the main repository. The different stages and jobs of the pipeline are depicted in the figure below. Note: This pipeline is currently outdated as we switched from Gitlab to Github. However, we still run unit, integration and lint checks as well as code coverage and deployment of the documentation.</p> Fig.1: The CI/CD pipeline which is executed after every push to the main repository. It consists of the stages test and deploy."},{"location":"getting_started/glossary/","title":"Glossary","text":""},{"location":"getting_started/glossary/#glossary","title":"Glossary","text":""},{"location":"getting_started/glossary/#data-life-cycle-object-dlco","title":"Data Life Cycle Object (DLCO)","text":"<p>The Data Lifecycle Object manages the runtime data that is required during the execution of one PFDL-File. It is dynamic, which allows variables and tasks defined in the PFDL to be instantiated, updated and deleted during runtime. </p>"},{"location":"getting_started/glossary/#execution-engine","title":"Execution Engine","text":"<p>The Execution Engine (EE) provides an interface that connects the PFDL Scheduler to the Field Level Devices.</p>"},{"location":"getting_started/glossary/#field-device","title":"Field Device","text":"<p>The Field level constitutes the lowest level of the automation pyramid and captures all kind of devices that are found in industrial manufacturing systems.  These devices are either sensors or actors and directly influence processes by measuring data or performing an arbitrary step of a manufacturing process. </p>"},{"location":"getting_started/glossary/#lexer","title":"Lexer","text":"<p>In lexical analysis using a lexer, the input characters of a source program are read in and then converted into a sequence of tokens. A token represents certain key words of the language or a sequence of input characters. This consists on the one hand of a token name and on the other hand of the text or the sequence of input of input characters that correspond to the token type. Within the parser, the token name is used to define the syntax of the language.</p>"},{"location":"getting_started/glossary/#parser","title":"Parser","text":"<p>A parser receives the generated tokens of the lexer and checks whether the sequence of token names can be generated via the grammar of the language. The syntax of a language is usually defined with the help of a context-free grammar. A tree structure (syntax tree or parse tree) is usually generated at the end of the parsing process.</p>"},{"location":"getting_started/glossary/#petri-net-generator","title":"Petri Net Generator","text":"<p>The Petri Net Generator is a module in the scheduler which receives an instance of the domain model of the PFDL and transforms it into a Petri Net.</p>"},{"location":"getting_started/glossary/#petri-net-logic","title":"Petri Net Logic","text":"<p>A module in the scheduler which handles the execution of the petri net and the firing of events from outside (e.g from the execution engines).</p>"},{"location":"getting_started/glossary/#scheduler","title":"Scheduler","text":"<p>The scheduler comprises almost the complete execution of a production order including the parsing of the PFDL description, model creation and validation and execution of the petri net. It interacts with the execution engines and informs them about services or tasks which started or finished.</p>"},{"location":"getting_started/glossary/#semantic-validation","title":"Semantic Validation","text":"<p>In the semantic validation process the scheduler validates the static semantic of the instance of the domain model of the PFDL. These errors can not be detected while parsing and have to be checked additionally.</p>"},{"location":"getting_started/glossary/#service","title":"Service","text":"<p>A Service in the PFDL corresponds to a service in a service oriented architecture. In the context of production and manufacturing a Service-call can be used to invoke a service of a field device of the factory floor.</p>"},{"location":"getting_started/glossary/#task","title":"Task","text":"<p>A Task is an executable unit which executes the statements within it sequentially. Instructions in a task can be service calls, calling other tasks and various control structures. A single Task can represent the whole production order or parts of it.</p>"},{"location":"getting_started/glossary/#visitor","title":"Visitor","text":"<p>The visitor design pattern describes a procedure to interact with objects in a composition. Methods can be encapsulated, which are executed on elements of an object structure. In the context of this project, the structure is the syntax tree generated by the parser. It can be determined in which order the nodes of the syntax tree are run through. This makes flexible traversal possible and it can be chosen which nodes of the syntax tree should be visited (which information is accessed).</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#installation","title":"Installation","text":"<p>This guide will lead you through the installation. Afterwards the scheduler will be tested with a simple PFDL file. We expect you to have cloned the official PFDL repository while trying the steps below.</p> <p>There are two ways to use the PFDL. You can use the grammar only or use the Scheduler. In the following we provide an installation guide for both cases.</p>"},{"location":"getting_started/installation/#grammar","title":"Grammar","text":"<p>At first you need the ANTLR tool to generate the Lexer and Parser files from the ANTLR grammar specifications. Check out the Quick Start guide on the official ANTLR site to learn how to install ANTLR on your system (Note: we use ANTLR4, there is no support for ANTLR3).</p> <p>To generate the files you can run the following command from the projects root directory:</p> <pre><code>    antlr4 -Dlanguage=Python3 -visitor PFDLLexer.g4 PFDLParser.g4\n</code></pre> <p>This will generate the files from the PFDLLexer.g4 and PFDLParser.g4 specification files. The -visitor argument makes sure that a Visitor class is generated too. This will help to obtain the model after parsing. The -Dlanguage argument specifies the code generation target language. In our case python is used.</p> <p>However, if you would like to use the PFDL grammar for your own purposes you can generate the files in a language of your choice too. A list of all possible targets and download links can be found here.</p>"},{"location":"getting_started/installation/#scheduler","title":"Scheduler","text":"<p>The scheduler and especially the scheduler class can be used like every other python module.</p>"},{"location":"getting_started/installation/#requirements","title":"Requirements","text":"<p>The following requirements are needed to run the scheduler:</p> <ul> <li>Pip packages from requirements.txt (<code>pip install -r requirements.txt</code>)</li> <li>GraphViz (if you want to use the scheduler/run the scheduler_demo.py)</li> </ul> <p>Check if you correctly installed GraphViz (On Windows you need to put the path of the bin folder which is in the GraphViz folder into the PATH environment variable. On Ubuntu it should be fine if you install it via apt or apt-get). The installation process is not checked for macOS yet. For troubleshooting on any OS visit the Download section of the official GraphViz documentation.</p>"},{"location":"getting_started/installation/#run-the-validation","title":"Run the validation","text":"<p>If you just want to validate your PFDL files run the following command from the root directory of the project. All errors will be printed in the console, so if nothing is shown the file is valid.</p> <pre><code>    python validate_pfdl_file.py &lt;path_to_pfdl_file&gt;\n</code></pre>"},{"location":"getting_started/installation/#run-the-scheduler","title":"Run the Scheduler","text":"<p>To make use of the scheduler you can import the scheduler class and use it like in the scheduler_demo.py. We will provide a pip package for the scheduler module later so there is no need to clone the repo anymore. If you want to run the scheduler from the command line, you can execute the scheduler_demo.py which is a small example program to demonstrate the use of the scheduler class. Run the following command from the root directory of the project.</p> <pre><code>    python scheduler_demo.py &lt;path_to_pfdl_file&gt;\n</code></pre> <p>It will parse the given file and validates it. If the program is valid a petri net will be generated in the root directory.</p>"},{"location":"getting_started/installation/#simple-example","title":"Simple Example","text":"<p>To test your installation you can run a simple PFDL file. The demo file implements a DemoInterface which uses the Scheduler and serves as demonstration of how to use the Scheduler. You can view the source code of the whole file here:</p> View Source of <code>scheduler_demo.py</code> <pre><code>\"\"\"This file contains an interface to demonstrate the use of the PFDL Scheduler.\"\"\"\n\n# standard libraries\nimport argparse\n\n# local sources\nfrom pfdl_scheduler.api.service_api import ServiceAPI\nfrom pfdl_scheduler.api.task_api import TaskAPI\nfrom pfdl_scheduler.model.struct import Struct\nfrom pfdl_scheduler.scheduler import Scheduler, Event\n\n\nclass DemoInterface:\n    \"\"\"A dummy interface which demonstrates the use of the scheduler functions.\n\n    At start the interface register its callback functions and variable access function\n    to the scheduler. The callback functions provide a simple debug message to show\n    the functionality of the scheduler.\n\n    Attributes:\n        scheduler: A Scheduler instance\n        wetness: A dummy variable which is used in the PFDL examples\n        parts_count: A dummy variable which is used in the PFDL examples\n    \"\"\"\n\n    def __init__(self, scheduler: Scheduler) -&gt; None:\n        \"\"\"Initialize the object\"\"\"\n        self.scheduler: Scheduler = scheduler\n        self.wetness: int = 11\n        self.parts_count: int = 3\n\n    def cb_task_started(self, task_api: TaskAPI) -&gt; None:\n        task_name = task_api.task.name\n        task_id = task_api.uuid\n        print(\"Task \" + task_name + \" with UUID '\" + task_id + \"' started\")\n\n    def cb_service_started(self, service_api: ServiceAPI) -&gt; None:\n        service_name = service_api.service.name\n        service_id = service_api.uuid\n        print(\"Service \" + service_name + \" with UUID '\" + service_id + \"' started\")\n\n    def cb_service_finished(self, service_api: ServiceAPI) -&gt; None:\n        service_name = service_api.service.name\n        service_id = service_api.uuid\n        print(\"Service \" + service_name + \" with UUID '\" + service_id + \"' finished\")\n\n    def cb_task_finished(self, task_api: TaskAPI) -&gt; None:\n        task_name = task_api.task.name\n        task_id = task_api.uuid\n        print(\"Task \" + task_name + \" with UUID '\" + task_id + \"' finished\")\n\n    def variable_access_function(self, var_name, task_context: TaskAPI) -&gt; Struct:\n        \"\"\"Simulate a variable access function which returns a Struct variable.\n\n        This dummy method simulates an access to variables from the PFDL. The returned structs\n        are used in the examples folder.\n\n        Returns:\n            A struct variable corresponding to the given variable name in the given task context.\n        \"\"\"\n        print(\"Request variable '\" + var_name + \"' from task with UUID '\" + task_context.uuid + \"'\")\n        dummy_struct = Struct()\n\n        if var_name == \"pr\" or var_name == \"dr\":\n            dummy_struct.attributes = {\"wetness\": self.wetness}\n        elif var_name == \"cr\":\n            dummy_struct.attributes = {\"parts_count\": self.parts_count}\n        return dummy_struct\n\n    def start(self):\n        self.scheduler.register_callback_task_started(self.cb_task_started)\n        self.scheduler.register_callback_service_started(self.cb_service_started)\n        self.scheduler.register_callback_service_finished(self.cb_service_finished)\n        self.scheduler.register_callback_task_finished(self.cb_task_finished)\n        self.scheduler.register_variable_access_function(self.variable_access_function)\n        self.scheduler.start()\n\n        while self.scheduler.running:\n            input_str = str(input(\"Wait for input:&gt;\"))\n            splitted = input_str.split(\",\")\n            service_id = splitted[0]\n            event_type = splitted[1]\n\n            event = Event(event_type=event_type, data={\"service_id\": service_id})\n            self.scheduler.fire_event(event)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Process some integers.\")\n    parser.add_argument(\"file_path\", type=str, help=\"the path for the PFDL file.\")\n    parser.add_argument(\n        \"--test_ids\",\n        action=\"store_true\",\n        help=\"services and tasks get test ids starting from 0.\",\n    )\n    args = parser.parse_args()\n    scheduler = Scheduler(args.file_path, args.test_ids)\n    demo_interface = DemoInterface(scheduler)\n    demo_interface.start()\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Within the scheduler_demo.py file the Scheduler is created and started with the given PFDL file. The start method of the interface registers the callback functions to the Scheduler so they are called when specific events occur. After the registration the scheduler is started and then executed in a while loop. In this loop an input to the Scheduler is emulated with the help of Python's input function. The given event of the user is then fired to the Scheduler.</p> <pre><code>def start(self):\n    self.scheduler.register_callback_task_started(self.cb_task_started)\n    self.scheduler.register_callback_service_started(self.cb_service_started)\n    self.scheduler.register_callback_service_finished(self.cb_service_finished)\n    self.scheduler.register_callback_task_finished(self.cb_task_finished)\n    self.scheduler.register_variable_access_function(self.variable_access_function)\n    self.scheduler.start()\n\n    while self.scheduler.running:\n        input_str = str(input(\"Wait for input:&gt;\"))\n        splitted = input_str.split(\",\")\n        service_id = splitted[0]\n        event_type = splitted[1]\n\n        event = Event(event_type=event_type, data={\"service_id\": service_id})\n        self.scheduler.fire_event(event)\n</code></pre> <p>There are four methods which serve as callback functions for the scheduler. The <code>cb_task_started</code> method for example gets called when a Task is started in the Scheduler. A TaskAPI object is passed to the function which gives context information about the started Task. In this simple example the UUID of the started Task and its name are being printed to the console. The UUID gets created when the Task is started and identifies the specific instance of the Task. If the same Task is called multiple times, for example in a loop, each instance get a unique ID for identification. The TaskAPI object consists of the called Task (or: Task definition), the unique ID and the TaskContext which is also a TaskAPI object. This TaskContext represents the calling Task (can also be none, if the TaskAPI object describes the <code>productionTask</code>).</p> <pre><code>def cb_task_started(self, task_api: TaskAPI) -&gt; None:\n    task_name = task_api.task.name\n    task_id = task_api.uuid\n    print(\"Task \" + task_name + \" with UUID '\" + task_id + \"' started\")\n\ndef cb_service_started(self, service_api: ServiceAPI) -&gt; None:\n    service_name = service_api.service.name\n    service_id = service_api.uuid\n    print(\"Service \" + service_name + \" with UUID '\" + service_id + \"' started\")\n\ndef cb_service_finished(self, service_api: ServiceAPI) -&gt; None:\n    service_name = service_api.service.name\n    service_id = service_api.uuid\n    print(\"Service \" + service_name + \" with UUID '\" + service_id + \"' finished\")\n\ndef cb_task_finished(self, task_api: TaskAPI) -&gt; None:\n    task_name = task_api.task.name\n    task_id = task_api.uuid\n    print(\"Task \" + task_name + \" with UUID '\" + task_id + \"' finished\")\n</code></pre> <p>The <code>variable_access_function</code> emulates the variable management of a real system. As you can see in this dummy function a Struct is created which is filled with a fixed value depending on the requested variable name. To test the PFDl example files the function creates Struct with reasonable values if the variable names are <code>pr</code>, <code>dr</code> or <code>cr</code> which are all used in the example files. A real variable access function would look up the variable name in some kind of storage / memory and return the real value of it.</p> <pre><code>def variable_access_function(self, var_name, task_context: TaskAPI) -&gt; Struct:\n    \"\"\"Simulate a variable access function which returns a Struct variable.\n\n    This dummy method simulates an access to variables from the PFDL. The returned structs\n    are used in the examples folder.\n\n    Returns:\n        A struct variable corresponding to the given variable name in the given task context.\n    \"\"\"\n    print(\"Request variable '\" + var_name + \"' from task with UUID '\" + task_context.uuid + \"'\")\n    dummy_struct = Struct()\n\n    if var_name == \"pr\" or var_name == \"dr\":\n        dummy_struct.attributes = {\"wetness\": self.wetness}\n    elif var_name == \"cr\":\n        dummy_struct.attributes = {\"parts_count\": self.parts_count}\n    return dummy_struct\n</code></pre> <p>Now it is time to test the DemoInterface. Before you start the Scheduler we explain in short the used PFDL file. In this simple scenario there is only the service <code>Painting</code>. This service could command a painting machine to paint the piece that is currently on it. To customize the painting process a <code>Color</code> parameter is passed to the service. The Struct <code>Color</code>, which is used as a description for Color variables, consists of the color name and a RGB value in form of an array. As the painting machine can measure the wetness of the piece, the service will return a <code>PaintResult</code> which contains the wetness. The whole production order starts with the <code>productionTask</code> and so from it the Task <code>paintingTask</code> is called which executes the <code>Painting</code> service. The example PFDL file looks like the following:</p> <pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintResult\n    wetness: number\nEnd\n\nTask productionTask\n    paintingTask\nEnd\n\nTask paintingTask\n    Painting\n        In\n            Color \n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        Out\n            pr: PaintResult\nEnd\n</code></pre> <p>Run the following command to start the scheduler_demo.py file with the simple PFDL example:</p> <pre><code>    python scheduler_demo.py examples/simple_task.pfdl\n</code></pre> <p>Now that the scheduler is started a png file with the name \"petri_net.png\" should have appeared in the temp folder of the project (if there is no temp folder, one will be created). This file shows the generated Petri net for the PFDL file. A token should be in the <code>Painting started</code> place.</p> <p>The demo waits for user input. As it is for testing purposes only, the syntax for firing an event is simplified. You can copy the UUID of the started service and seperate it with a comma and write <code>service_finished</code>. This will tell the scheduler that the service with the given UUID is finished. Substitute the UUID with the one of the service and enter the command.</p> <pre><code>    &lt;uuid of the service&gt;,service_finished\n</code></pre> <p>After entering this command the token should be in the last place of the petri net as the service has finished now and no other statement is inside the <code>paintingTask</code>. If the scheduler_demo terminates after the command and the token is in the <code>productionTask_finished</code> place everything works like it should.</p> <p>Both states of the petri net are depicted in Figure 1. On the left you can see the initial petri net after the scheduling starts. A token is set on the <code>Painting started</code> place. The petri net on the right shows the state after the service is finished.</p> Fig.1: On the left you can see the initial petri net after the scheduling starts. A token is set on the Painting started place. The petri net on the right shows the state after the service is finished  <p>If everything looks as described you have succesfully run your first PFDL file with the Scheduler! You can now work on your own PFDL files or start integrating the Scheduler into your projects. For advanced examples visit the Examples section.</p>"},{"location":"pfdl/comments/","title":"Comments","text":""},{"location":"pfdl/comments/#comments","title":"Comments","text":"<p>A comment starts with a hash character (<code>#</code>) that is not part of a string literal, and ends at the end of the physical line. That means a comment can appear on its own or at the end of a statement. In-line comments are not supported.</p> <p>This example shows a mimicked multi-line comment that consists of three <code>#</code> that are joined together:</p> <pre><code>###\n# This task shows the usage of comments\n###\nTask paintingTask\n    Painting\n        In\n            # Represents a color\n            Color\n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        # Task output\n        Out\n            pr: PaintingResult\nEnd # End of the task\n</code></pre>"},{"location":"pfdl/condition/","title":"Condition","text":""},{"location":"pfdl/condition/#condition","title":"Condition","text":"<p>Because some production steps needs to fulfill conditions sometimes there is a control structure <code>Condition</code> for this specific case. The <code>Condition</code> block consists of a <code>Condition</code> which includes a boolean expression, a <code>Passed</code> block in which instructions are given for the case that the boolean expression evaluates to True. If the expression is not met the statements inside the <code>Failed</code> block are executed.</p> <p>In the following example the <code>paintingTask</code> dries the painted material afterwards by calling the Service <code>Drying</code>. The output of the Service call is saved in a variable <code>dr</code> of type <code>DryingResult</code> which provides information about the wetness of the paint. If the wetness in form of a number value is below a certain threshold (here: 10) the Task should continue with the next production steps, otherwise it dries again.</p> <p>The <code>Failed</code> block is optional: You can omit it and if the condition is not met the scheduler will execute the next statement after the <code>Condition</code> block.</p> <pre><code>Struct DryingResult\n   wetness: number\nEnd\n\nTask paintingTask\n    ...\n    Drying\n        Out\n            dr: DryingResult\n\n    Condition\n        dr.wetness &lt; 10\n    Passed\n        ... # continue \n    Failed\n        Drying\n            In\n                dr\n            Out\n                dr: DryingResult\nEnd\n</code></pre>"},{"location":"pfdl/introduction/","title":"Introduction","text":""},{"location":"pfdl/introduction/#the-production-flow-description-language","title":"The Production Flow Description Language","text":"<p>The main building blocks of a PFDL program are Structs and Tasks. Within the task different statements can be executed like a Service call or control structures like loops, conditions, concurrency and synchronization.</p>"},{"location":"pfdl/introduction/#formal-grammar","title":"Formal Grammar","text":"<p>In the following we present you the formal grammar of the PFDL. The grammar definiton can be consulted to understand the syntax.</p> <p>This grammar is a simplified representation of a context free grammar. Terminal symbols are represented in bold. Parentheses indicate an optional usage while the pipe symbol <code>|</code> denotes a choice.  Entities that are overlined can be repeated zero, one or more times. An overline with a plus sign was added in addition which implicates a repetition of at least one or more.</p> Fig. 1: The formal grammar of the Production Flow Description Language (PFDL)."},{"location":"pfdl/introduction/#pfdl-overview","title":"PFDL Overview","text":"<p>The following figure depicts the formal grammar above graphically. A visual representation of the different functionalities is followed by the corresponding code snippets in the PFDL.</p> Fig. 2: A summary of the different building blocks of the PFDL. The left side visualises the functionality while the right side is the corresponding PFDL code snippet."},{"location":"pfdl/introduction/#allowed-characters","title":"Allowed Characters","text":"<p>Most of the correct syntax can be obtained from the formal grammar above. In the following sections we will explain the correct syntax for the different building blocks of the language (Structs, Tasks, etc.).</p> <p>We use the terms lower- and uppercase strings definied as followed in the different sections:</p> <p>Lowercase String: starts with a lowercase char and after that you can use every letter, number and the char '_'. Regular Expression: <code>[a-z][a-zA-Z0-9_]*</code></p> <p>Uppercase String: same as lowercase, except for an uppercase char at the beginning. Regular Expression: <code>[A-Z][a-zA-Z0-9_]*</code></p>"},{"location":"pfdl/loop/","title":"Loop","text":""},{"location":"pfdl/loop/#loop","title":"Loop","text":"<p>To execute statements for a specified number of repetitions, the usage of the <code>Loop</code> keyword is required. There are two types of loops available: Counting Loops and While Loops.</p>"},{"location":"pfdl/loop/#while-loop","title":"While Loop","text":"<p>While loops can be defined by adding the keyword <code>While</code> and an boolean expression after the <code>Loop</code> keyword.</p> <pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n\nStruct PaintingResult\n    wetness: number\nEnd\n\nStruct DryingResult\n   wetness: number\nEnd\n\nTask productionTask\n    paintAndCutTask\nEnd\n\nTask paintAndCutTask\n    ...\n\n    Loop While dr_1.wetness &gt; 5\n        Drying\n            In\n                dr_1\n            Out\n                dr_1: DryingResult\nEnd\n</code></pre>"},{"location":"pfdl/loop/#counting-loop","title":"Counting Loop","text":"<p>To define a counting loop one have to specify a counting variable followed by the keyword <code>To</code> and a number (fixed value or variable) to define the counting limit.</p> <pre><code>...\nStruct SheetPart\n    width: number\n    hight: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n\nTask paintAndCutTask\n    ...\n\n    Loop i To cr.parts_count\n        millingTask\n            In\n                cr.sheet_parts[i]\nEnd\n\nTask millingTask\n    In \n        part_in: SheetPart\n    Milling\n        In\n            part_in\nEnd\n</code></pre>"},{"location":"pfdl/loop/#parallel-keyword-in-counting-loop","title":"Parallel keyword in Counting Loop","text":"<p>If you want to iterate over the elements of an array and a (partial) job has to be executed in parallel for each element, the parallel keyword can be written before a counting loop. This starts as many jobs in parallel as there would be loop iterations. This is a supplement to the parallel keyword, as only a fixed number of orders can be started in parallel. However, it can only be known at runtime how many jobs have to be started in parallel. The example below shows the usage of the parallel loop. The task <code>task_1</code> is started as many times as there are parts.</p> <pre><code>Task parallel_task\n    ...\n\n    Parallel Loop i To cr.parts_count\n        task_1\n            In\n                cr.sheet_parts[i]\nEnd\n</code></pre>"},{"location":"pfdl/parallel/","title":"Parallel","text":""},{"location":"pfdl/parallel/#parallel","title":"Parallel","text":"<p>To exexute Tasks in parallel the <code>Parallel</code> keyword is used. All Tasks within a Parallel block will be executed concurrently by the Scheduler. The keyword can be used inside a Task and only Tasks are allowed here.</p> <p>In the example below the productionTask starts the two Tasks <code>paintingTask</code> and <code>cuttingTask</code> in parallel.</p> <pre><code>Task productionTask\n    Parallel\n        paintingTask\n        cuttingTask\nEnd\n\nTask paintingTask\n    ...\nEnd\n\nTask cuttingTask\n    ...\nEnd\n</code></pre> <p>The Scheduler waits for the finishing of all concurrent Tasks. Once they are finished the Scheduler continues with the next statements inside the corresponding Task.</p> <p>If we add a new TaskCall after the Parallel statement in the example above an implicit synchronization is possible. The new Task <code>syncTask</code> will be executed once the Tasks <code>paintingTask</code> and <code>cuttingTask</code> are finished.</p> <pre><code>Task productionTask\n    Parallel\n        paintingTask\n        cuttingTask\n    syncTask\nEnd\n\nTask paintingTask\n    ...\nEnd\n\nTask cuttingTask\n    ...\nEnd\n\nTask syncTask\n    ...\nEnd\n</code></pre>"},{"location":"pfdl/service/","title":"Service","text":""},{"location":"pfdl/service/#service","title":"Service","text":"<p>A Service in the PFDL corresponds to a service in a service oriented architecture. In the context of production and manufacturing a Service-call can be used to invoke a service of a field device of the factory floor. </p> <p>It is important to note that the Service-call within the PFDL file can be mapped to every service that is avaiable. Due to the scheduler it is possible to pass input into the scheduler. After the scheduling starts for each defined service inside the PFDL file a UUID is generated.  This UUID can be used to map the \"logical\" service to the real service. For example: You specify a Service \"Painting\" inside the PFDL file. You can know decide to which of your own services this logical Service corresponds. If you register a callback function you get notified when Services starts and receive the logical name of the started service.</p> <p>A Service-call in the PFDL looks like the following: <pre><code>&lt;Service name&gt;\n    In\n        &lt;input parameters&gt;\n    Out\n        &lt;output parameters&gt;\n</code></pre></p> <p>The service parameters can be either passed directly via a struct instantiation in a JSON-manner or by passing a variable name, which refers to an already defined and instantiated struct. Values that are returned by a Service-call can be stored in a struct. Consequently, an output of a service call can be the the input for the next service.</p> <p>A real example of a Service-call is shown below. The service <code>Painting</code> is invoked with a parameter from type <code>Color</code>. This is an exmaple for the initialization in a JSON-manner. The ouput of the service will be saved in a variable <code>pr</code> of type <code>PaintingResult</code>.</p> <pre><code>Painting\n    In\n        Color\n        {\n            \"name\": \"green\",\n            \"rgb\": [0, 255, 0]\n        }\n    Out\n        pr : PaintingResult\n</code></pre> <p>Note: Every statement within a task that starts with an Uppercase character is assumed to be a Service-call. There is no additional keyword to specifiy a Service-call.</p>"},{"location":"pfdl/struct/","title":"Struct","text":""},{"location":"pfdl/struct/#structs","title":"Structs","text":"<p>A struct is a collection of variables. PFDL is strongly typed, where each variable of a struct has a name as an identifier and a designated data type. The supported data types are equal to JSON\u2019s data types: string, number, boolean, and arrays. Structs can be used to define the input and output of Service-calls as well as Task-calls.</p> <p>The following example shows a simple struct definition. The struct <code>Color</code> has 2 attributes, <code>name</code> and <code>rgb</code>.</p> <p>As already explained, Arrays are also a possible type for struct attributes. In the example below the type of attribute <code>rgb</code> is an number array with fixed size 3. It is also possible to omit the number for dynmaic arrays (e.g. a service returns a struct with an dynamic array).</p> <pre><code>Struct Color\n    name: string\n    rgb: number[3]\nEnd\n</code></pre>"},{"location":"pfdl/struct/#composition","title":"Composition","text":"<p>Attributes of structs can also have other Structs as type. This allows a composition and reuse of other structs inside a struct.</p> <p>In the following example the Struct <code>CuttingResult</code> has an attribute <code>sheet_parts</code> which is a dynamic array of type <code>SheetPart</code>. In this example scenario a machine cut a piece in multiple parts with different sizes and it is only known at runtime how many parts there will be.</p> <pre><code>Struct SheetPart\n    width: number\n    height: number\nEnd\n\nStruct CuttingResult\n    parts_count: number\n    sheet_parts: SheetPart[]\nEnd\n</code></pre>"},{"location":"pfdl/struct/#instantiation","title":"Instantiation","text":"<p>Structs must be instantiated in the form of a JSON object. You can also create JSON objects inside this instantiation to create composite structs.</p> <pre><code>Color\n{\n    \"name\": \"green\",\n    \"rgb\": [0, 255, 0]\n}\n\n# nested struct creation\nCuttingResult\n{\n    \"parts_count\": 2,\n    \"sheet_parts\": [\n        {\n            width: 5,\n            length: 10,\n            height: 3\n        },\n        {\n            width: 5,\n            length: 5,\n            height: 3\n        }\n    ]\n}\n</code></pre>"},{"location":"pfdl/task/","title":"Task","text":""},{"location":"pfdl/task/#task","title":"Task","text":"<p>A Task is an executable unit which executes the statements within sequentially. The name of the Task should be a string that starts with a lowercase character.</p>"},{"location":"pfdl/task/#the-production-task","title":"The Production Task","text":"<p>A Task with the name <code>productionTask</code> serves as the starting point of the production order. Every PFDL program has to define this Task. This is comparable to a main method in conventional programming languages. The examples below show the use of such a Task.</p>"},{"location":"pfdl/task/#call-a-task","title":"Call a Task","text":"<p>Tasks can be called within other Tasks just like Service calls. In the example below the <code>productionTask</code> calls the Task <code>paintingTask</code> which executes the Service <code>Painting</code>. <pre><code>Task productionTask\n    paintingTask\nEnd\n\nTask paintingTask\n    Painting\n        In\n            Color \n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        Out\n            pr: PaintingResult\nEnd\n</code></pre></p>"},{"location":"pfdl/task/#input-and-output-of-tasks","title":"Input and Output of Tasks","text":"<p>When Tasks are called they can receive input parameters and return an output too (just like Services). This can be used to transfer variables from one Task to another. Variables are always bound to a Service so with this functionality it is possible to use a variable from one Task in other Tasks.</p> <p>The input must be defined at the start of a Task definition with the keyword <code>In</code>. Afer the <code>In</code> keyword one can insert an arbitrary amount of variable definitions, consisting of the variable name that is used within the Task and its type.</p> <p>The output must be defined at the end of a Task definition with the keyword <code>Out</code>. Only variable names known in the Tasks can be used here per line as output of the Task.</p> <p>In the following example the Task <code>paintingTask</code> defines an input and an output. The input variable <code>paint_color</code> must be of type <code>Color</code>. After the Service <code>Painting</code> is finished we receive a variable <code>pr</code> of type <code>PaintingResult</code>. This variable is defined as the output of the Task. The <code>productionTask</code> calls the Task <code>paintingTask</code> and instantiates a <code>Color</code> variable which serves as the input. The output is defined in the variable <code>pr</code> of type <code>PaintingResult</code>.</p> <p>Note: Variable <code>pr</code> has the same name and the same value as in <code>paintingTask</code> but technically they are two different variables. <pre><code>Task productionTask\n    paintingTask\n        In\n            Color \n            {\n                \"name\": \"green\",\n                \"rgb\": [0, 255, 0]\n            }\n        Out\n            pr: PaintingResult\nEnd\n\nTask paintingTask\n    In\n        paint_color: Color\n    Painting\n        In\n            paint_color\n        Out\n            pr: PaintingResult\n    Out\n        pr\nEnd\n</code></pre></p>"},{"location":"scheduler/","title":"Introduction","text":""},{"location":"scheduler/#using-the-pfdl-scheduler","title":"Using the PFDL scheduler","text":"<p>This section can be used as a reference while developing software with the PFDL Scheduler. All classes that can be used are documented here.</p> <p>The Scheduler section gives an overview of all functions that are needed for starting the scheduler and registering your callback functions to get status updates while the petri net is traversed.</p> <p>In the SchedulerAPI section the API classes can be found which will be passed to you by the callback functions. This objects refering to a called Task or Service provides identification and context informationen to keep track of the current status of the production order.</p> <p>If you want to work with the generated model of the PFDL file the Model classes section gives an detailed overview over all model classes and their attributes.</p> <p>If you want to work on the code of the PFDL Scheduler the Developers Reference section provides documentation about all the remaining internal classes.</p>"},{"location":"scheduler/api/","title":"Scheduler API","text":""},{"location":"scheduler/api/#pfdl-scheduler-api","title":"PFDL Scheduler API","text":"<p>In this section further information about the functions that can be used from the PFDL Scheduler is given.</p>"},{"location":"scheduler/api/#pfdl_scheduler.api.service_api.ServiceAPI","title":"<code>pfdl_scheduler.api.service_api.ServiceAPI(service, task_context, uuid='', in_loop=False)</code>  <code>dataclass</code>","text":"<p>Represents a called Service. Represents a Service or Service Call in the langauge which can be mapped to a real service that can be executed. Attributes:     service: A description of the called Service.     task_context: A TaskAPI representaiton of the Task from which the service was called.     uuid: A UUID4 which is generated at object creation and is used in the scheduling.     in_loop: A boolean indicating whether the Service was called within a loop.</p> <p>Initialize the object. Args:     service: A description of the called Service.     task_context: A TaskAPI representaiton of the Task from which the service was called.     uuid: A UUID4 which is generated at object creation and is used in the scheduling.     in_loop: A boolean indicating whether the Service was called within a loop.</p>"},{"location":"scheduler/api/#pfdl_scheduler.api.task_api.TaskAPI","title":"<code>pfdl_scheduler.api.task_api.TaskAPI(task, task_context, uuid='', task_call=None, in_loop=False)</code>  <code>dataclass</code>","text":"<p>Represents a called Task.</p> <p>Represents a specific entity of a called Task. It combines the information of the Task itself and the parameters of the call. A TaskAPI object is used in the task started and finished callback which are called by the scheduler.</p> <p>Attributes:</p> Name Type Description <code>task</code> <code>Task</code> <p>A description of the called Task.</p> <code>task_context</code> <code>TaskAPI</code> <p>A TaskAPI representaiton of the Task from which the called task was invoked.</p> <code>uuid</code> <code>str</code> <p>A UUID4 which is generated at object creation and is used in the scheduling.</p> <code>task_call</code> <code>TaskCall</code> <p>Information about the input and output parameters of the called Task.</p> <code>in_loop</code> <code>bool</code> <p>A boolean indicating whether the Task was called within a loop.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>A description of the called Task.</p> required <code>task_context</code> <code>TaskAPI</code> <p>A TaskAPI representaiton of the Task from which the called task was invoked.</p> required <code>uuid</code> <code>str</code> <p>A UUID4 which is generated at object creation and is used in the scheduling.</p> <code>''</code> <code>task_call</code> <code>TaskCall</code> <p>Information about the input and output parameters of the called Task.</p> <code>None</code> <code>in_loop</code> <code>bool</code> <p>A boolean indicating whether the Task was called within a loop.</p> <code>False</code>"},{"location":"scheduler/dashboard/","title":"Dashboard API","text":""},{"location":"scheduler/developer_reference/","title":"Developer Reference","text":""},{"location":"scheduler/developer_reference/#developer-reference","title":"Developer Reference","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler","title":"<code>pfdl_scheduler</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.api","title":"<code>api</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api","title":"<code>observer_api</code>","text":"<p>This class contains classes to enable the Observer pattern.</p> <p>The <code>NotificationTye</code> class is an enum class which is used for setting the type of the notification.</p> <p>The abstract <code>Observer</code> class represents the observers in the pattern and requires an <code>update</code> method which is called by a <code>Subject</code> object. Here, the type of the notification and the corresponding data is required.</p> <p>The abstract <code>Subject</code> class represents the subjects in the observer pattern. It provides methods to attach or detach observers and to notify them.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.NotificationType","title":"<code>NotificationType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Declares the type of Notification in the observer pattern.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Observer","title":"<code>Observer</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The Observer interface declares the update method, used by subjects.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Observer.update","title":"<code>update(notification_type, data)</code>  <code>abstractmethod</code>","text":"<p>Receive update from subject.</p> Source code in <code>pfdl_scheduler/api/observer_api.py</code> <pre><code>@abstractmethod\ndef update(self, notification_type: NotificationType, data: Any) -&gt; None:\n    \"\"\"Receive update from subject.\"\"\"\n    pass\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Subject","title":"<code>Subject</code>","text":"<p>             Bases: <code>ABC</code></p> <p>The Subject interface declares a set of methods for managing subscribers.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Subject.attach","title":"<code>attach(observer)</code>  <code>abstractmethod</code>","text":"<p>Attach an observer to the subject.</p> Source code in <code>pfdl_scheduler/api/observer_api.py</code> <pre><code>@abstractmethod\ndef attach(self, observer: Observer) -&gt; None:\n    \"\"\"Attach an observer to the subject.\"\"\"\n    pass\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Subject.detach","title":"<code>detach(observer)</code>  <code>abstractmethod</code>","text":"<p>Detach an observer from the subject.</p> Source code in <code>pfdl_scheduler/api/observer_api.py</code> <pre><code>@abstractmethod\ndef detach(self, observer: Observer) -&gt; None:\n    \"\"\"Detach an observer from the subject.\"\"\"\n    pass\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.observer_api.Subject.notify","title":"<code>notify(notification_type, data)</code>  <code>abstractmethod</code>","text":"<p>Notify all observers about an event.</p> Source code in <code>pfdl_scheduler/api/observer_api.py</code> <pre><code>@abstractmethod\ndef notify(self, notification_type: NotificationType, data: Any) -&gt; None:\n    \"\"\"Notify all observers about an event.\"\"\"\n    pass\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.service_api","title":"<code>service_api</code>","text":"<p>Contains the ServiceAPI class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.service_api.ServiceAPI","title":"<code>ServiceAPI(service, task_context, uuid='', in_loop=False)</code>  <code>dataclass</code>","text":"<p>Represents a called Service. Represents a Service or Service Call in the langauge which can be mapped to a real service that can be executed. Attributes:     service: A description of the called Service.     task_context: A TaskAPI representaiton of the Task from which the service was called.     uuid: A UUID4 which is generated at object creation and is used in the scheduling.     in_loop: A boolean indicating whether the Service was called within a loop.</p> <p>Initialize the object. Args:     service: A description of the called Service.     task_context: A TaskAPI representaiton of the Task from which the service was called.     uuid: A UUID4 which is generated at object creation and is used in the scheduling.     in_loop: A boolean indicating whether the Service was called within a loop.</p> Source code in <code>pfdl_scheduler/api/service_api.py</code> <pre><code>def __init__(\n    self,\n    service: Service,\n    task_context: TaskAPI,\n    uuid: str = \"\",\n    in_loop: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the object.\n    Args:\n        service: A description of the called Service.\n        task_context: A TaskAPI representaiton of the Task from which the service was called.\n        uuid: A UUID4 which is generated at object creation and is used in the scheduling.\n        in_loop: A boolean indicating whether the Service was called within a loop.\n    \"\"\"\n    if uuid == \"\":\n        self.uuid: str = str(uuid4())\n    else:\n        self.uuid: str = uuid\n    self.in_loop: bool = in_loop\n    self.service: Service = service\n    self.task_context: TaskAPI = task_context\n    self.input_parameters: List[Union[str, List[str], Struct]] = copy.deepcopy(\n        service.input_parameters\n    )\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.task_api","title":"<code>task_api</code>","text":"<p>Contains the TaskAPI class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.api.task_api.TaskAPI","title":"<code>TaskAPI(task, task_context, uuid='', task_call=None, in_loop=False)</code>  <code>dataclass</code>","text":"<p>Represents a called Task.</p> <p>Represents a specific entity of a called Task. It combines the information of the Task itself and the parameters of the call. A TaskAPI object is used in the task started and finished callback which are called by the scheduler.</p> <p>Attributes:</p> Name Type Description <code>task</code> <code>Task</code> <p>A description of the called Task.</p> <code>task_context</code> <code>TaskAPI</code> <p>A TaskAPI representaiton of the Task from which the called task was invoked.</p> <code>uuid</code> <code>str</code> <p>A UUID4 which is generated at object creation and is used in the scheduling.</p> <code>task_call</code> <code>TaskCall</code> <p>Information about the input and output parameters of the called Task.</p> <code>in_loop</code> <code>bool</code> <p>A boolean indicating whether the Task was called within a loop.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>task</code> <code>Task</code> <p>A description of the called Task.</p> required <code>task_context</code> <code>TaskAPI</code> <p>A TaskAPI representaiton of the Task from which the called task was invoked.</p> required <code>uuid</code> <code>str</code> <p>A UUID4 which is generated at object creation and is used in the scheduling.</p> <code>''</code> <code>task_call</code> <code>TaskCall</code> <p>Information about the input and output parameters of the called Task.</p> <code>None</code> <code>in_loop</code> <code>bool</code> <p>A boolean indicating whether the Task was called within a loop.</p> <code>False</code> Source code in <code>pfdl_scheduler/api/task_api.py</code> <pre><code>def __init__(\n    self,\n    task: Task,\n    task_context: \"TaskAPI\",\n    uuid: str = \"\",\n    task_call: TaskCall = None,\n    in_loop: bool = False,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        task: A description of the called Task.\n        task_context: A TaskAPI representaiton of the Task from which the called task was invoked.\n        uuid: A UUID4 which is generated at object creation and is used in the scheduling.\n        task_call: Information about the input and output parameters of the called Task.\n        in_loop: A boolean indicating whether the Task was called within a loop.\n    \"\"\"\n    if uuid == \"\":\n        self.uuid: str = str(uuid4())\n    else:\n        self.uuid: str = uuid\n    self.task: Task = task\n    self.task_context: TaskAPI = task_context\n    self.task_call: TaskCall = task_call\n\n    if task_call:\n        self.input_parameters: List[Union[str, List[str], Struct]] = copy.deepcopy(\n            task_call.input_parameters\n        )\n    else:\n        self.input_parameters: List[Union[str, List[str], Struct]] = []\n    self.in_loop: bool = in_loop\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.extension","title":"<code>extension</code>","text":"<p>Contains the start up script used in the VSCode extension.</p> <p>A program that shall be executed in the VS Code extension which has a string containing a PFDL program as input as well as the name of the corresponding file.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model","title":"<code>model</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.array","title":"<code>array</code>","text":"<p>Contains the Array class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.array.Array","title":"<code>Array(type_of_elements='', values=None, context=None)</code>","text":"<p>Represents an Array in the PFDL.</p> <p>Used as as an array definition or a returned array with elements in it.</p> <p>Attributes:</p> Name Type Description <code>type_of_elements</code> <code>str</code> <p>A string representing the type of the elements inside the array.</p> <code>values</code> <code>List[Any]</code> <p>A list of elements of the Array (empty if it is a array definition).</p> <code>length</code> <code>int</code> <p>An integer for the length of the Array. If it is not defined it gets the value -1.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>type_of_elements</code> <code>str</code> <p>A string representing the type of the elements inside the array.</p> <code>''</code> <code>values</code> <code>List[Any]</code> <p>A list of elements of the Array (empty if it is a array definition).</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/array.py</code> <pre><code>def __init__(\n    self,\n    type_of_elements: str = \"\",\n    values: List[Any] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        type_of_elements: A string representing the type of the elements inside the array.\n        values: A list of elements of the Array (empty if it is a array definition).\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.type_of_elements: str = type_of_elements\n    if values:\n        self.length: int = len(values)\n        self.values: List[Any] = values\n    else:\n        self.values: List[Any] = []\n        self.length: int = -1\n    self.context: ParserRuleContext = context\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.array.Array.append_value","title":"<code>append_value(value)</code>","text":"<p>Adds an element to the array and increase the length.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value that should be added to the array.</p> required Source code in <code>pfdl_scheduler/model/array.py</code> <pre><code>def append_value(self, value: Any) -&gt; None:\n    \"\"\"Adds an element to the array and increase the length.\n\n    Args:\n        value: The value that should be added to the array.\n    \"\"\"\n    if self.length == -1:  # Set length to 0 for arrays with undefined length\n        self.length = 0\n    self.values.append(value)\n    self.length = self.length + 1\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.array.Array.length_defined","title":"<code>length_defined()</code>","text":"<p>Returns whether the lenght of the array is defined.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the length of the array is defined.</p> Source code in <code>pfdl_scheduler/model/array.py</code> <pre><code>def length_defined(self) -&gt; bool:\n    \"\"\"Returns whether the lenght of the array is defined.\n\n    Returns:\n        True if the length of the array is defined.\n    \"\"\"\n    return self.length != -1\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.condition","title":"<code>condition</code>","text":"<p>Contains the Condition class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.condition.Condition","title":"<code>Condition(expression=None, passed_stmts=None, failed_stmts=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a conditional statement in the PFDL.</p> <p>A Condition consists of a boolean expression which has to be satisfied in order to execute the statements in the Passed block. Otherwise the statements in the Failed block will be executed.</p> <p>Attributes:</p> Name Type Description <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict (see Visitor for the dict structure).</p> <code>passed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is satisfied.</p> <code>failed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is not satisfied.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict (see Visitor for the dict structure).</p> <code>None</code> <code>passed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is satisfied.</p> <code>None</code> <code>failed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is not satisfied.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/condition.py</code> <pre><code>def __init__(\n    self,\n    expression: Dict = None,\n    passed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = None,\n    failed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        expression: Boolean expression in form of a dict (see Visitor for the dict structure).\n        passed_stmts: List of statements which are executed when the expression is satisfied.\n        failed_stmts: List of statements which are executed when the expression is not satisfied.\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.expression: Dict = expression\n\n    if passed_stmts:\n        self.passed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = passed_stmts\n    else:\n        self.passed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = []\n\n    if failed_stmts:\n        self.failed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = failed_stmts\n    else:\n        self.failed_stmts: List[Union[Service, TaskCall, \"Loop\", \"Condition\"]] = []\n\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.counting_loop","title":"<code>counting_loop</code>","text":"<p>Contains the CountingLoop class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.counting_loop.CountingLoop","title":"<code>CountingLoop(statements=None, counting_variable='', limit='', parallel=False, context=None)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Loop</code></p> <p>Represents a Counting Loop in the PFDL.</p> <p>Counting loops count a variable from an initial value to a given upper limit. If the parallel keyword was used, this loop executes the statements in the loop body in parallel as many times as the loop would iterate.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <p>List of statements inside the loop body.</p> <code>context</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <p>Maps other attributes with ANTLR context objects.</p> <code>counting_variable</code> <code>str</code> <p>Name of the variable which is counted in the loop.</p> <code>limit</code> <code>str</code> <p>Integer for the upper limit.</p> <code>parallel</code> <code>bool</code> <p>A boolean indicating if the loop is a parallel loop or not.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>counting_variable</code> <code>str</code> <p>Name of the variable which is counted in the loop.</p> <code>''</code> <code>limit</code> <code>str</code> <p>Integer for the upper limit.</p> <code>''</code> <code>parallel</code> <code>bool</code> <p>A boolean indicating if the loop is a parallel loop or not.</p> <code>False</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/counting_loop.py</code> <pre><code>def __init__(\n    self,\n    statements: List[Union[Service, TaskCall, Loop, Condition]] = None,\n    counting_variable: str = \"\",\n    limit: str = \"\",\n    parallel: bool = False,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        statements: List of statements inside the loop body.\n        counting_variable: Name of the variable which is counted in the loop.\n        limit: Integer for the upper limit.\n        parallel: A boolean indicating if the loop is a parallel loop or not.\n        context: ANTLR context object of this class.\n    \"\"\"\n    Loop.__init__(self, statements, context)\n    self.counting_variable: str = counting_variable\n    self.limit: str = limit\n    self.parallel: bool = parallel\n    self.uuid = str(uuid.uuid4())\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.loop","title":"<code>loop</code>","text":"<p>Contains the Loop class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.loop.Loop","title":"<code>Loop(statements=None, context=None)</code>  <code>dataclass</code>","text":"<p>The base class for the PFDL loops.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/loop.py</code> <pre><code>def __init__(\n    self,\n    statements: List[Union[Service, TaskCall, \"Loop\", Condition]] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        statements: List of statements inside the loop body.\n        context: ANTLR context object of this class.\n    \"\"\"\n    if statements:\n        self.statements: List[Union[Service, TaskCall, \"Loop\", Condition]] = statements\n    else:\n        self.statements: List[Union[Service, TaskCall, \"Loop\", Condition]] = []\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.parallel","title":"<code>parallel</code>","text":"<p>Contains the Parallel class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.parallel.Parallel","title":"<code>Parallel(task_calls=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Parallel statement in the PFDL.</p> <p>Each task within this instruction is executed in parallel with the calling task. When all parallel tasks are finished, the calling task continues its execution.</p> <p>Attributes:</p> Name Type Description <code>task_calls</code> <code>List[TaskCall]</code> <p>List of Task Calls in the Parallel statement.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>task_calls</code> <code>List[TaskCall]</code> <p>List of Task Calls in the Parallel statement.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/parallel.py</code> <pre><code>def __init__(\n    self, task_calls: List[TaskCall] = None, context: ParserRuleContext = None\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        task_calls: List of Task Calls in the Parallel statement.\n        context: ANTLR context object of this class.\n    \"\"\"\n    if task_calls:\n        self.task_calls: List[TaskCall] = task_calls\n    else:\n        self.task_calls: List[TaskCall] = []\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.process","title":"<code>process</code>","text":"<p>Contains the Process class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.process.Process","title":"<code>Process(structs=None, tasks=None)</code>  <code>dataclass</code>","text":"<p>Represents a production process described in a PFDL file.</p> <p>A Process consists of multiple Structs and Tasks. A Process object gets created after the visitor traverses the syntax tree.</p> <p>Attributes:</p> Name Type Description <code>structs</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Struct names to the Struct objects.</p> <code>task</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Task names to the Task objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>structs</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Struct names to the Struct objects.</p> <code>None</code> <code>tasks</code> <code>Dict[str, Task]</code> <p>A dict for mapping the Task names to the Task objects.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/process.py</code> <pre><code>def __init__(self, structs: Dict[str, Struct] = None, tasks: Dict[str, Task] = None) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        structs: A dict for mapping the Struct names to the Struct objects.\n        tasks: A dict for mapping the Task names to the Task objects.\n    \"\"\"\n    if structs:\n        self.structs: Dict[str, Struct] = structs\n    else:\n        self.structs: Dict[str, Struct] = {}\n    if tasks:\n        self.tasks: Dict[str, Task] = tasks\n    else:\n        self.tasks: Dict[str, Task] = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.service","title":"<code>service</code>","text":"<p>Contains the Service class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.service.Service","title":"<code>Service(name='', input_parameters=None, output_parameters=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Service or Service Call in the PFDL.</p> <p>Represents a Service or Service Call in the langauge which can be mapped to a real service that can be executed.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the Service.</p> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the Service.</p> <code>output_parameters</code> <code>OrderedDict[str, Union[str, Array]]</code> <p>List of output parameters of the Service.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the Service.</p> <code>''</code> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the Service.</p> <code>None</code> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the Service.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/service.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"\",\n    input_parameters: List[Union[str, List[str], Struct]] = None,\n    output_parameters: Dict[str, Union[str, Array]] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        name: A string representing the name of the Service.\n        input_parameters: List of input parameters of the Service.\n        output_parameters: List of output parameters of the Service.\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.name: str = name\n\n    if input_parameters:\n        self.input_parameters: List[Union[str, List[str], Struct]] = input_parameters\n    else:\n        self.input_parameters: List[Union[str, List[str], Struct]] = []\n\n    if output_parameters:\n        self.output_parameters: OrderedDict[str, Union[str, Array]] = output_parameters\n    else:\n        self.output_parameters: OrderedDict[str, Union[str, Array]] = OrderedDict()\n\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.struct","title":"<code>struct</code>","text":"<p>Contains the Struct class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.struct.Struct","title":"<code>Struct(name='', attributes=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Struct in the PFDL.</p> <p>Data container for Services and Taskcalls. Used both for Struct definitons and instantiated Structs.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the Struct.</p> <code>attributes</code> <code>Dict[str, Union[str, Array, Struct]]</code> <p>A dict which maps the attribute names to the defined type         or a value (if its a instantiated struct).</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the Struct.</p> <code>''</code> <code>attributes</code> <code>Dict[str, Union[str, Array, Struct]]</code> <p>A dict which maps the attribute names to the defined type         or a value (if its a instantiated struct).</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/struct.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"\",\n    attributes: Dict[str, Union[str, Array, \"Struct\"]] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        name: A string representing the name of the Struct.\n        attributes: A dict which maps the attribute names to the defined type\n                    or a value (if its a instantiated struct).\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.name: str = name\n    if attributes:\n        self.attributes: Dict[str, Union[str, Array, \"Struct\"]] = attributes\n    else:\n        self.attributes: Dict[str, Union[str, Array, \"Struct\"]] = {}\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.struct.Struct.from_json","title":"<code>from_json(json_string, error_handler, struct_context)</code>  <code>classmethod</code>","text":"<p>Creates a Struct instance out of the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_string</code> <code>str</code> <p>A JSON string desribing the Struct.</p> required <code>error_handler</code> <code>ErrorHandler</code> <p>An ErrorHandler instance used for printing errors.</p> required <p>Returns:</p> Type Description <code>Struct</code> <p>The Struct which was created from the JSON string.</p> Source code in <code>pfdl_scheduler/model/struct.py</code> <pre><code>@classmethod\ndef from_json(\n    cls, json_string: str, error_handler: ErrorHandler, struct_context: ParserRuleContext\n) -&gt; \"Struct\":\n    \"\"\"Creates a Struct instance out of the given JSON string.\n\n    Args:\n        json_string: A JSON string desribing the Struct.\n        error_handler: An ErrorHandler instance used for printing errors.\n\n    Returns:\n        The Struct which was created from the JSON string.\n    \"\"\"\n    json_object = json.loads(json_string)\n    struct = parse_json(json_object, error_handler, struct_context)\n    return struct\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.struct.parse_json","title":"<code>parse_json(json_object, error_handler, struct_context)</code>","text":"<p>Parses the JSON Struct initialization.</p> <p>Parameters:</p> Name Type Description Default <code>json_object</code> <code>Dict</code> <p>A JSON object describing the Struct.</p> required <code>error_handler</code> <code>ErrorHandler</code> <p>An ErrorHandler instance used for printing errors.</p> required <code>struct_context</code> <code>ParserRuleContext</code> <p>The ANTLR struct context the struct corresponds to.</p> required <p>Returns:</p> Type Description <code>Struct</code> <p>A Struct object representing the initialized Struct.</p> Source code in <code>pfdl_scheduler/model/struct.py</code> <pre><code>def parse_json(\n    json_object: Dict, error_handler: ErrorHandler, struct_context: ParserRuleContext\n) -&gt; Struct:\n    \"\"\"Parses the JSON Struct initialization.\n\n    Args:\n        json_object: A JSON object describing the Struct.\n        error_handler: An ErrorHandler instance used for printing errors.\n        struct_context: The ANTLR struct context the struct corresponds to.\n\n    Returns:\n        A Struct object representing the initialized Struct.\n    \"\"\"\n    struct = Struct()\n    struct.context = struct_context\n\n    for identifier, value in json_object.items():\n        if isinstance(value, (int, float, str, bool)):\n            struct.attributes[identifier] = value\n        elif isinstance(value, list):\n            array = Array()\n            array.context = struct_context\n            struct.attributes[identifier] = array\n            for element in value:\n                if isinstance(element, (int, float, str, bool)):\n                    if isinstance(element, bool):\n                        array.type_of_elements = \"boolean\"\n                    elif isinstance(element, (int, float)):\n                        array.type_of_elements = \"number\"\n                    else:\n                        array.type_of_elements = \"string\"\n                    array.append_value(element)\n                elif isinstance(element, dict):\n                    inner_struct = parse_json(element, error_handler, struct_context)\n                    array.append_value(inner_struct)\n        elif isinstance(value, dict):\n            inner_struct = parse_json(value, error_handler, struct_context)\n            struct.attributes[identifier] = inner_struct\n    return struct\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.task","title":"<code>task</code>","text":"<p>Contains the Task class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.task.Task","title":"<code>Task(name='', statements=None, variables=None, input_parameters=None, output_parameters=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Task in the PFDL.</p> <p>A Task contains statements which are executed sequentially. It is possible to define input and output parameters of a Task.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the Task.</p> <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed sequentially.</p> <code>variables</code> <code>Dict[str, Union[str, Array]]</code> <p>Dict for mapping variable names with their values.</p> <code>input_parameters</code> <code>OrderedDict[str, Union[str, Array]]</code> <p>OrderedDict for mapping input parameter names with their values.</p> <code>output_parameters</code> <code>List[str]</code> <p>List of variable names as output parameters.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the Task.</p> <code>''</code> <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed sequentially.</p> <code>None</code> <code>variables</code> <code>Dict[str, Union[str, Array]]</code> <p>Dict for mapping variable names with their values.</p> <code>None</code> <code>input_parameters</code> <code>OrderedDict[str, Union[str, Array]]</code> <p>OrderedDict for mapping input parameter names with their values.</p> <code>None</code> <code>output_parameters</code> <code>List[str]</code> <p>List of variable names as output parameters.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/task.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"\",\n    statements: List[Union[Service, TaskCall, Loop, Condition]] = None,\n    variables: Dict[str, Union[str, Array]] = None,\n    input_parameters: OrderedDict[str, Union[str, Array]] = None,\n    output_parameters: List[str] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        name: A string representing the name of the Task.\n        statements: List of statements which are executed sequentially.\n        variables: Dict for mapping variable names with their values.\n        input_parameters: OrderedDict for mapping input parameter names with their values.\n        output_parameters: List of variable names as output parameters.\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.name: str = name\n\n    if statements:\n        self.statements: List[Union[Service, TaskCall, Loop, Condition]] = statements\n    else:\n        self.statements: List[Union[Service, TaskCall, Loop, Condition]] = []\n\n    if variables:\n        self.variables: Dict[str, Union[str, Array]] = variables\n    else:\n        self.variables: Dict[str, Union[str, Array]] = {}\n\n    if input_parameters:\n        self.input_parameters: OrderedDict[str, Union[str, Array]] = input_parameters\n    else:\n        self.input_parameters: OrderedDict[str, Union[str, Array]] = {}\n\n    if output_parameters:\n        self.output_parameters: List[str] = output_parameters\n    else:\n        self.output_parameters: List[str] = []\n\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.task_call","title":"<code>task_call</code>","text":"<p>Contains the TaskCall class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.task_call.TaskCall","title":"<code>TaskCall(name='', input_parameters=None, output_parameters=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a TaskCall in the PFDL.</p> <p>Provides information about the name and call parameters of a Task which is called within another Task.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the TaskCall.</p> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the TaskCall.</p> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the TaskCall.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the TaskCall.</p> <code>''</code> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the TaskCall.</p> <code>None</code> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the TaskCall.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/task_call.py</code> <pre><code>def __init__(\n    self,\n    name: str = \"\",\n    input_parameters: List[Union[str, List[str], Struct]] = None,\n    output_parameters: Dict[str, Union[str, Array]] = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        name: A string representing the name of the TaskCall.\n        input_parameters: List of input parameters of the TaskCall.\n        output_parameters: List of output parameters of the TaskCall.\n        context: ANTLR context object of this class.\n    \"\"\"\n    self.name: str = name\n\n    if input_parameters:\n        self.input_parameters: List[Union[str, List[str], Struct]] = input_parameters\n    else:\n        self.input_parameters: List[Union[str, List[str], Struct]] = []\n\n    if output_parameters:\n        self.output_parameters: Dict[str, Union[str, Array]] = output_parameters\n    else:\n        self.output_parameters: Dict[str, Union[str, Array]] = {}\n\n    self.context: ParserRuleContext = context\n    self.context_dict: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.while_loop","title":"<code>while_loop</code>","text":"<p>Contains the WhileLoop class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.model.while_loop.WhileLoop","title":"<code>WhileLoop(statements=None, expression=None, context=None)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Loop</code></p> <p>Represents a While Loop in the PFDL.</p> <p>Loops until conditional statement (expression) is satisfied.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <p>List of statements inside the loop body.</p> <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict.</p> <code>context</code> <code>Dict</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code> Source code in <code>pfdl_scheduler/model/while_loop.py</code> <pre><code>def __init__(\n    self,\n    statements: List[Union[Service, TaskCall, Loop, Condition]] = None,\n    expression: Dict = None,\n    context: ParserRuleContext = None,\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        statements: List of statements inside the loop body.\n        expression: Boolean expression in form of a dict.\n        context: ANTLR context object of this class.\n    \"\"\"\n    Loop.__init__(self, statements, context)\n\n    if expression:\n        self.expression: Dict = expression\n    else:\n        self.expression: Dict = {}\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.parser","title":"<code>parser</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.parser.pfdl_tree_visitor","title":"<code>pfdl_tree_visitor</code>","text":"<p>Contains PFDLTreeVisitor class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.parser.pfdl_tree_visitor.PFDLTreeVisitor","title":"<code>PFDLTreeVisitor(error_handler)</code>","text":"<p>             Bases: <code>PFDLParserVisitor</code></p> <p>Traverses the given parse tree and store program information in a Process object.</p> <p>This class overrides the generated visitor methods from the ANTLR generated PFDLParserVisitor. A Process object is created and gets filled while traversing the syntax tree.</p> <p>Attributes:</p> Name Type Description <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors while visiting.</p> <code>current_task</code> <code>Task</code> <p>Reference to the currently visited Task. Every visitor method can access it.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors while visiting.</p> required Source code in <code>pfdl_scheduler/parser/pfdl_tree_visitor.py</code> <pre><code>def __init__(self, error_handler: ErrorHandler) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        error_handler: ErrorHandler instance for printing errors while visiting.\n    \"\"\"\n    self.error_handler: ErrorHandler = error_handler\n    self.current_task: Task = None\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.parser.pfdl_tree_visitor.PFDLTreeVisitor.visitProgram","title":"<code>visitProgram(ctx)</code>","text":"<p>Starts the visiting of the syntax tree of the given PFDL program.</p> Source code in <code>pfdl_scheduler/parser/pfdl_tree_visitor.py</code> <pre><code>def visitProgram(self, ctx) -&gt; Process:\n    \"\"\"Starts the visiting of the syntax tree of the given PFDL program.\"\"\"\n    process = Process()\n\n    if ctx.children:\n        for child in ctx.children:\n            process_component = self.visit(child)\n\n            if isinstance(process_component, Struct):\n                if process_component.name not in process.structs:\n                    process.structs[process_component.name] = process_component\n                else:\n                    error_msg = (\n                        f\"A Struct with the name '{process_component.name}' \"\n                        \"is already defined\"\n                    )\n                    self.error_handler.print_error(error_msg, context=child)\n            elif isinstance(process_component, Task):\n                if process_component.name not in process.tasks:\n                    process.tasks[process_component.name] = process_component\n                else:\n                    error_msg = (\n                        f\"A Task with the name '{process_component.name}' \" \"is already defined\"\n                    )\n                    self.error_handler.print_error(error_msg, context=child)\n    return process\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net","title":"<code>petri_net</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.callbacks","title":"<code>callbacks</code>","text":"<p>Contains the PetriNetCallbacks class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.callbacks.PetriNetCallbacks","title":"<code>PetriNetCallbacks(task_started=None, service_started=None, service_finished=None, condition_started=None, while_loop_started=None, counting_loop_started=None, parallel_loop_started=None, task_finished=None)</code>  <code>dataclass</code>","text":"<p>Internal callback functions that can be registered in the petri net.</p> <p>Attributes:</p> Name Type Description <code>task_started</code> <code>Callable[[TaskAPI], Any]</code> <p>Callback function which gets called when a task is started.</p> <code>service_started</code> <code>Callable[[ServiceAPI], Any]</code> <p>Callback function which gets called when a service is started.</p> <code>service_finished</code> <code>Callable[[ServiceAPI], Any]</code> <p>Callback function which gets called when a task is started.</p> <code>condition_started</code> <code>Callable[[Condition, str, str, TaskAPI], Any]</code> <p>Callback function which gets called when a task is started.</p> <code>while_loop_started</code> <code>Callable[[WhileLoop, str, str, TaskAPI], Any]</code> <p>Callback function which gets called when a while loop is started.</p> <code>counting_loop_started</code> <code>Callable[[CountingLoop, str, str, TaskAPI], Any]</code> <p>Callback function which gets called when a counting loop is started.</p> <code>parallel_loop_started</code> <code>Callable[[CountingLoop, TaskAPI, List, str, str], Any]</code> <p>Callback function which gets called when a parallel loop is started.</p> <code>task_finished</code> <code>Callable[[TaskAPI], Any]</code> <p>Callback function which gets called when a task is finished.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer","title":"<code>drawer</code>","text":"<p>Functions defined here set attributes for drawing the petri net.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer.draw_arcs","title":"<code>draw_arcs(arc, attr)</code>","text":"<p>Set attributes for drawing arcs.</p> Source code in <code>pfdl_scheduler/petri_net/drawer.py</code> <pre><code>def draw_arcs(arc, attr):\n    \"\"\"Set attributes for drawing arcs.\"\"\"\n    if isinstance(arc, snakes.nets.Inhibitor):\n        attr[\"arrowhead\"] = INHIBITOR_ARC_ARROW_HEAD\n    attr[\"label\"] = DEFAULT_ARC_LABEL\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer.draw_graph","title":"<code>draw_graph(graph, attr)</code>","text":"<p>Set attributes for drawing the net.</p> Source code in <code>pfdl_scheduler/petri_net/drawer.py</code> <pre><code>def draw_graph(graph, attr):\n    \"\"\"Set attributes for drawing the net.\"\"\"\n    attr[\"margin\"] = GRAPH_MARGIN\n    attr[\"newrank\"] = NEW_RANK_VALUE\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer.draw_petri_net","title":"<code>draw_petri_net(net, file_path, file_ending='.png')</code>","text":"<p>Calls the draw method form the Snakes module on the given PetriNet.</p> Source code in <code>pfdl_scheduler/petri_net/drawer.py</code> <pre><code>def draw_petri_net(net, file_path, file_ending=\".png\"):\n    \"\"\"Calls the draw method form the Snakes module on the given PetriNet.\"\"\"\n    with draw_lock:\n        net.draw(\n            file_path + file_ending,\n            LAYOUT_METHOD,\n            graph_attr=draw_graph,\n            arc_attr=draw_arcs,\n            place_attr=draw_place,\n            trans_attr=draw_transition,\n            cluster_attr=draw_clusters,\n        )\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer.draw_place","title":"<code>draw_place(place, attr)</code>","text":"<p>Set attributes for drawing places.</p> Source code in <code>pfdl_scheduler/petri_net/drawer.py</code> <pre><code>def draw_place(place, attr):\n    \"\"\"Set attributes for drawing places.\"\"\"\n    if place.label(\"name\") != \"\":\n        attr[\"xlabel\"] = place.label(\"name\")\n    else:\n        attr[\"xlabel\"] = place.name\n\n    attr[\"group\"] = place.label(\"group_id\")\n\n    if 1 in place:\n        attr[\"label\"] = \"&amp;bull;\"\n    else:\n        attr[\"label\"] = PLACE_LABEL\n    attr[\"shape\"] = PLACE_SHAPE\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.drawer.draw_transition","title":"<code>draw_transition(trans, attr)</code>","text":"<p>Set attributes for drawing transitions.</p> Source code in <code>pfdl_scheduler/petri_net/drawer.py</code> <pre><code>def draw_transition(trans, attr):\n    \"\"\"Set attributes for drawing transitions.\"\"\"\n\n    attr[\"label\"] = \"\"  # TRANSITION_LABEL\n    attr[\"shape\"] = TRANSITION_SHAPE\n    attr[\"height\"] = TRANSITION_HEIGHT\n    attr[\"width\"] = TRANSITION_WIDTH\n    attr[\"fillcolor\"] = TRANSITION_FILL_COLOR\n    attr[\"group\"] = trans.label(\"group_id\")\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator","title":"<code>generator</code>","text":"<p>Contains the PetriNetGenerator class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator","title":"<code>PetriNetGenerator(path_for_image='', used_in_extension=False, generate_test_ids=False, draw_net=True, file_name='petri_net')</code>","text":"<p>Generates a Petri Net from a given Process object which corresponds to a PFDL file.</p> <p>Attributes:</p> Name Type Description <code>path_for_image</code> <code>str</code> <p>The path where the image of the generated Petri Net is saved.</p> <code>net</code> <code>PetriNet</code> <p>The snakes Petri Net instance.</p> <code>tasks</code> <code>Dict[str, Task]</code> <p>A dict representing the Tasks of the given Process object.</p> <code>transition_dict</code> <code>OrderedDict</code> <p>A dict for mapping the UUIDs of the Transitions to their behavior.</p> <code>place_dict</code> <code>Dict</code> <p>A dict for mapping the service id to the place name.</p> <code>task_started_id</code> <code>str</code> <p>The id of the 'Task started' place.</p> <code>callbacks</code> <code>PetriNetCallbacks</code> <p>A PetriNetCallbacks instance representing functions called while execution.</p> <code>generate_test_ids</code> <code>bool</code> <p>A boolean indicating if test ids (counting from 0) should be generated.</p> <code>used_in_extension</code> <code>bool</code> <p>A boolean indicating if the Generator is used within the extension.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>path_for_image</code> <code>str</code> <p>The path where the image of the generated Petri Net is saved.</p> <code>''</code> <code>used_in_extension</code> <code>bool</code> <p>A boolean indicating if the Generator is used within the extension.</p> <code>False</code> <code>generate_test_ids</code> <code>bool</code> <p>A boolean indicating if test ids (counting from 0) should be generated.</p> <code>False</code> <code>draw_net</code> <code>bool</code> <p>A boolean indicating if the petri net should be drawn.</p> <code>True</code> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def __init__(\n    self,\n    path_for_image: str = \"\",\n    used_in_extension: bool = False,\n    generate_test_ids: bool = False,\n    draw_net: bool = True,\n    file_name: str = \"petri_net\",\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        path_for_image: The path where the image of the generated Petri Net is saved.\n        used_in_extension: A boolean indicating if the Generator is used within the extension.\n        generate_test_ids: A boolean indicating if test ids (counting from 0) should be generated.\n        draw_net: A boolean indicating if the petri net should be drawn.\n    \"\"\"\n\n    if used_in_extension:\n        self.path_for_image: str = \"../media/\" + file_name\n    elif path_for_image == \"\":\n        Path(\"./temp\").mkdir(parents=True, exist_ok=True)\n        self.path_for_image: str = \"temp/\" + file_name\n    else:\n        Path(\"./temp\").mkdir(parents=True, exist_ok=True)\n        self.path_for_image: str = path_for_image + \"/temp/\" + file_name\n\n    self.net: PetriNet = PetriNet(\"petri_net\")\n    self.draw_net: bool = draw_net\n    self.tasks: Dict[str, Task] = None\n    self.transition_dict: OrderedDict = OrderedDict()\n    self.place_dict: Dict = {}\n    self.task_started_id: str = \"\"\n    self.callbacks: PetriNetCallbacks = PetriNetCallbacks()\n    self.generate_test_ids: bool = generate_test_ids\n    self.used_in_extension: bool = used_in_extension\n    self.tree = None\n    self.file_name = file_name\n    self.cluster = None\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.add_callback","title":"<code>add_callback(transition_id, callback_function, *args)</code>","text":"<p>Registers the given callback function in the transition_dict.</p> <p>If the transition the transition_id refers to is fired, the callback function will be called with the given arguments inside the PetriNetLogic class.</p> <p>Parameters:</p> Name Type Description Default <code>transition_id</code> <code>str</code> <p>The UUID of the transition where the callback is called if fired.</p> required <code>callback_function</code> <code>Callable</code> <p>The callback function which should be called.</p> required <code>*args</code> <code>Any</code> <p>Arguments with which the callback function is called.</p> <code>()</code> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def add_callback(self, transition_id: str, callback_function: Callable, *args: Any) -&gt; None:\n    \"\"\"Registers the given callback function in the transition_dict.\n\n    If the transition the transition_id refers to is fired, the callback function\n    will be called with the given arguments inside the PetriNetLogic class.\n\n    Args:\n        transition_id: The UUID of the transition where the callback is called if fired.\n        callback_function: The callback function which should be called.\n        *args: Arguments with which the callback function is called.\n    \"\"\"\n    if not self.used_in_extension:\n        callback = functools.partial(callback_function, *args)\n        if transition_id not in self.transition_dict:\n            self.transition_dict[transition_id] = []\n\n        self.transition_dict[transition_id].append(callback)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_condition","title":"<code>generate_condition(condition, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generate Petri Net components for the Condition statement.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The ids of the last transitions of the Condition petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_condition(\n    self,\n    condition: Condition,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; List[str]:\n    \"\"\"Generate Petri Net components for the Condition statement.\n\n    Returns:\n        The ids of the last transitions of the Condition petri net component.\n    \"\"\"\n    group_id = str(uuid.uuid4())\n    condition_node = Node(group_id, \"Condition\", node)\n\n    passed_id = create_place(\"Passed\", self.net, group_id)\n    failed_id = create_place(\"Failed\", self.net, group_id)\n\n    expression_id = create_place(\n        \"If \" + self.parse_expression(condition.expression),\n        self.net,\n        group_id,\n    )\n\n    first_passed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    first_failed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n\n    self.net.add_input(expression_id, first_passed_transition_id, Value(1))\n    self.net.add_input(expression_id, first_failed_transition_id, Value(1))\n\n    self.net.add_input(passed_id, first_passed_transition_id, Value(1))\n    self.net.add_input(failed_id, first_failed_transition_id, Value(1))\n\n    finished_id = create_place(\"Condition_Finished\", self.net, group_id)\n\n    second_passed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    self.net.add_output(finished_id, second_passed_transition_id, Value(1))\n\n    cluster = Cluster([passed_id, failed_id, expression_id, finished_id])\n    node.cluster.add_child(cluster)\n\n    cluster_passed = Cluster([first_passed_transition_id, second_passed_transition_id])\n    cluster_failed = Cluster([first_failed_transition_id])\n    cluster.add_child(cluster_passed)\n    cluster.add_child(cluster_failed)\n    condition_node.cluster = cluster_passed\n\n    self.generate_statements(\n        task_context,\n        condition.passed_stmts,\n        first_passed_transition_id,\n        second_passed_transition_id,\n        condition_node,\n        in_loop,\n    )\n\n    self.net.add_output(expression_id, first_transition_id, Value(1))\n    self.net.add_input(finished_id, second_transition_id, Value(1))\n\n    args = (condition, passed_id, failed_id, task_context)\n    self.add_callback(first_transition_id, self.callbacks.condition_started, *args)\n\n    if condition.failed_stmts:\n        condition_node.cluster = cluster_failed\n        second_failed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n        cluster_failed.add_node(second_failed_transition_id)\n        self.generate_statements(\n            task_context,\n            condition.failed_stmts,\n            first_failed_transition_id,\n            second_failed_transition_id,\n            condition_node,\n            in_loop,\n        )\n\n        self.net.add_output(finished_id, second_failed_transition_id, Value(1))\n        return [second_passed_transition_id, second_failed_transition_id]\n    else:\n        self.net.add_output(finished_id, first_failed_transition_id, Value(1))\n        return [second_passed_transition_id, first_failed_transition_id]\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_counting_loop","title":"<code>generate_counting_loop(loop, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generates the Petri Net components for a Couting Loop.</p> <p>Returns:</p> Type Description <code>str</code> <p>The id of the last transition of the CountingLoop petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_counting_loop(\n    self,\n    loop: CountingLoop,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; str:\n    \"\"\"Generates the Petri Net components for a Couting Loop.\n\n    Returns:\n        The id of the last transition of the CountingLoop petri net component.\n    \"\"\"\n    if loop.parallel:\n        return self.generate_parallel_loop(\n            loop, task_context, first_transition_id, second_transition_id, node\n        )\n\n    group_id = str(uuid.uuid4())\n    counting_loop_node = Node(group_id, \"Counting Loop\", node)\n    loop_id = create_place(\"Loop\", self.net, group_id)\n\n    loop_text = \"Loop\"\n\n    loop_statements_id = create_place(loop_text, self.net, group_id)\n    loop_finished_id = create_place(\"Number of Steps Done\", self.net, group_id)\n\n    condition_passed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    condition_failed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    iteration_step_done_transition_id = create_transition(\"\", \"\", self.net, group_id)\n\n    self.net.add_input(loop_id, condition_passed_transition_id, Value(1))\n    self.net.add_input(loop_statements_id, condition_passed_transition_id, Value(1))\n    self.net.add_input(loop_id, condition_failed_transition_id, Value(1))\n    self.net.add_input(loop_finished_id, condition_failed_transition_id, Value(1))\n    self.net.add_output(loop_id, iteration_step_done_transition_id, Value(1))\n\n    loop_done_id = create_place(\"Loop Done\", self.net, group_id)\n\n    cluster = Cluster(\n        [\n            loop_id,\n            loop_statements_id,\n            loop_finished_id,\n            condition_passed_transition_id,\n            condition_failed_transition_id,\n            iteration_step_done_transition_id,\n            loop_done_id,\n        ]\n    )\n\n    node.cluster.add_child(cluster)\n    counting_loop_node.cluster = cluster\n\n    self.generate_statements(\n        task_context,\n        loop.statements,\n        condition_passed_transition_id,\n        iteration_step_done_transition_id,\n        counting_loop_node,\n        True,\n    )\n\n    self.net.add_output(loop_done_id, condition_failed_transition_id, Value(1))\n    self.net.add_output(loop_id, first_transition_id, Value(1))\n    self.net.add_input(loop_done_id, second_transition_id, Value(1))\n\n    args = (loop, loop_statements_id, loop_finished_id, task_context)\n    self.add_callback(first_transition_id, self.callbacks.counting_loop_started, *args)\n    self.add_callback(\n        iteration_step_done_transition_id, self.callbacks.counting_loop_started, *args\n    )\n\n    return condition_failed_transition_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_parallel","title":"<code>generate_parallel(parallel, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generate the Petri Net components for a Parallel statement.</p> <p>Returns:</p> Type Description <code>str</code> <p>The id of the last transition of the Parallel petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_parallel(\n    self,\n    parallel: Parallel,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; str:\n    \"\"\"Generate the Petri Net components for a Parallel statement.\n\n    Returns:\n        The id of the last transition of the Parallel petri net component.\n    \"\"\"\n\n    group_id = str(uuid.uuid4())\n    parallel_node = Node(group_id, \"Parallel\", node)\n\n    sync_id = create_transition(\"\", \"\", self.net, group_id)\n    parallel_finished_id = create_place(\"Parallel finished\", self.net, group_id)\n\n    cluster = Cluster([], Cluster([sync_id, parallel_finished_id]))\n    node.cluster.add_child(cluster)\n    parallel_node.cluster = cluster\n\n    for task_call in parallel.task_calls:\n        parallel_cluster = Cluster([])\n        cluster.add_child(parallel_cluster)\n        parallel_node.cluster = parallel_cluster\n        self.generate_task_call(\n            task_call, task_context, first_transition_id, sync_id, parallel_node, in_loop\n        )\n\n    self.net.add_output(parallel_finished_id, sync_id, Value(1))\n    self.net.add_input(parallel_finished_id, second_transition_id, Value(1))\n    return sync_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_parallel_loop","title":"<code>generate_parallel_loop(loop, task_context, first_transition_id, second_transition_id, node)</code>","text":"<p>Generates the static petri net components for a ParallelLoop.</p> <p>This method will generate a placeholder for the ParallelLoop. The real amount of parallel startet Tasks is only known at runtime.</p> <p>Returns:</p> Type Description <code>str</code> <p>The id of the last transition of the ParallelLoop petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_parallel_loop(\n    self,\n    loop: CountingLoop,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n) -&gt; str:\n    \"\"\"Generates the static petri net components for a ParallelLoop.\n\n    This method will generate a placeholder for the ParallelLoop. The real amount\n    of parallel startet Tasks is only known at runtime.\n\n    Returns:\n        The id of the last transition of the ParallelLoop petri net component.\n    \"\"\"\n\n    group_id = str(uuid.uuid4())\n    parallel_loop_node = Node(group_id, \"Parallel Loop\", node)\n\n    parallel_loop_started = create_place(\n        \"Start \" + loop.statements[0].name + \" in parallel\",\n        self.net,\n        group_id,\n    )\n    cluster = Cluster([parallel_loop_started])\n    node.cluster.add_child(cluster)\n    parallel_loop_node.cluster = cluster\n    self.net.add_output(parallel_loop_started, first_transition_id, Value(1))\n    self.net.add_input(parallel_loop_started, second_transition_id, Value(1))\n\n    args = (\n        loop,\n        task_context,\n        loop.statements[0],\n        parallel_loop_started,\n        first_transition_id,\n        second_transition_id,\n        parallel_loop_node,\n    )\n    self.add_callback(first_transition_id, self.callbacks.parallel_loop_started, *args)\n    return second_transition_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_petri_net","title":"<code>generate_petri_net(process)</code>","text":"<p>Generates a Petri Net from the given Process object.</p> <p>Starts from the 'productionTask' and iterates over his statements. For each statement type like Condition or TaskCall a Petri Net component is generated. All components get connected at the end.</p> <p>Returns:</p> Type Description <code>PetriNet</code> <p>A PetriNet instance representing the generated net.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_petri_net(self, process: Process) -&gt; PetriNet:\n    \"\"\"Generates a Petri Net from the given Process object.\n\n    Starts from the 'productionTask' and iterates over his statements.\n    For each statement type like Condition or TaskCall a Petri Net component\n    is generated. All components get connected at the end.\n\n    Returns:\n        A PetriNet instance representing the generated net.\n    \"\"\"\n    self.tasks = process.tasks\n    for task in process.tasks.values():\n        if task.name == \"productionTask\":\n            group_id = str(uuid.uuid4())\n            self.tree = Node(group_id, task.name)\n\n            task_context = TaskAPI(task, None)\n            if self.generate_test_ids:\n                task_context.uuid = \"0\"\n\n            self.task_started_id = create_place(\n                task.name + \"_started\", self.net, group_id, [0, 0]\n            )\n            connection_id = create_transition(\"\", \"\", self.net, group_id)\n\n            self.add_callback(connection_id, self.callbacks.task_started, task_context)\n\n            self.net.add_input(self.task_started_id, connection_id, Value(1))\n            self.task_finished_id = create_place(task.name + \"_finished\", self.net, group_id)\n\n            second_connection_id = create_transition(\"\", \"\", self.net, group_id)\n\n            self.tree.cluster = Cluster(\n                [\n                    self.task_started_id,\n                    connection_id,\n                    second_connection_id,\n                    self.task_finished_id,\n                ]\n            )\n            self.generate_statements(\n                task_context, task.statements, connection_id, second_connection_id, self.tree\n            )\n            self.net.add_output(self.task_finished_id, second_connection_id, Value(1))\n\n            self.add_callback(second_connection_id, self.callbacks.task_finished, task_context)\n\n    # assign new clusters before drawing\n    self.net.clusters = self.tree.cluster\n\n    if self.draw_net:\n        json_string = json.dumps(self.tree.toJSON(), indent=4)\n        draw_petri_net(self.net, self.path_for_image, \".dot\")\n        draw_petri_net(self.net, self.path_for_image, \".png\")\n        with open(self.path_for_image + \".dot\", \"a\") as file:\n            file.write(\"\\ncall_tree:\")\n            file.write(json_string)\n\n    return self.net\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_service","title":"<code>generate_service(service, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generate the Petri Net components for a Service Call.</p> <p>Returns:</p> Type Description <code>str</code> <p>The id of the last transition of the Service petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_service(\n    self,\n    service: Service,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; str:\n    \"\"\"Generate the Petri Net components for a Service Call.\n\n    Returns:\n        The id of the last transition of the Service petri net component.\n    \"\"\"\n    group_id = str(uuid.uuid4())\n    Node(group_id, service.name, node)\n\n    service_api = ServiceAPI(service, task_context, in_loop=in_loop)\n\n    service_started_id = create_place(service.name + \" started\", self.net, group_id)\n    service_finished_id = create_place(service.name + \" finished\", self.net, group_id)\n\n    self.place_dict[service_api.uuid] = service_finished_id\n\n    service_done_id = create_place(service.name + \" done\", self.net, group_id)\n    service_done_transition_id = create_transition(\"service_done\", \"\", self.net, group_id)\n\n    self.add_callback(first_transition_id, self.callbacks.service_started, service_api)\n    self.add_callback(service_done_transition_id, self.callbacks.service_finished, service_api)\n\n    self.net.add_input(service_started_id, service_done_transition_id, Value(1))\n    self.net.add_input(service_finished_id, service_done_transition_id, Value(1))\n    self.net.add_output(service_done_id, service_done_transition_id, Value(1))\n\n    self.net.add_output(service_started_id, first_transition_id, Value(1))\n    self.net.add_input(service_done_id, second_transition_id, Value(1))\n\n    node.cluster.add_child(\n        (\n            Cluster(\n                [\n                    service_started_id,\n                    service_finished_id,\n                    service_done_transition_id,\n                    service_done_id,\n                ]\n            )\n        )\n    )\n    return service_done_transition_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_statements","title":"<code>generate_statements(task_context, statements, first_connection_id, last_connection_id, node, in_loop=False)</code>","text":"<p>Generate Petri Net components for each statement in the given Task</p> <p>Iterate over the statements of the given Tasks and generate the corresponding Petri Net components. Connect the individual components with each other via a transition.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The ids of the last connections (transitions).</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_statements(\n    self,\n    task_context: TaskAPI,\n    statements: List,\n    first_connection_id: str,\n    last_connection_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; List[str]:\n    \"\"\"Generate Petri Net components for each statement in the given Task\n\n    Iterate over the statements of the given Tasks and generate the corresponding\n    Petri Net components. Connect the individual components with each other via a\n    transition.\n\n    Returns:\n        The ids of the last connections (transitions).\n    \"\"\"\n    current_connection_id = \"\"\n    previous_connection_id = first_connection_id\n\n    connection_ids = []\n    for i, statement in enumerate(statements):\n        multiple_statements = len(statements) &gt; 1\n\n        # only create a transition when there is more than 1 statement\n        # and we are not in the last iteration\n        if multiple_statements:\n            if i &lt; len(statements) - 1:\n                current_connection_id = create_transition(\n                    \"connection\", \"\", self.net, node.group_id\n                )\n                node.cluster.add_node(current_connection_id)\n            else:\n                current_connection_id = last_connection_id\n        else:\n            previous_connection_id = first_connection_id\n            current_connection_id = last_connection_id\n\n        args = (\n            statement,\n            task_context,\n            previous_connection_id,\n            current_connection_id,\n            node,\n            in_loop,\n        )\n\n        if isinstance(statement, Service):\n            connection_ids = [self.generate_service(*args)]\n        elif isinstance(statement, TaskCall):\n            connection_ids = self.generate_task_call(*args)\n        elif isinstance(statement, Parallel):\n            connection_ids = [self.generate_parallel(*args)]\n        elif isinstance(statement, CountingLoop):\n            connection_ids = [self.generate_counting_loop(*args)]\n        elif isinstance(statement, WhileLoop):\n            connection_ids = [self.generate_while_loop(*args)]\n        else:\n            connection_ids = self.generate_condition(*args)\n\n        previous_connection_id = current_connection_id\n\n    return connection_ids\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_task_call","title":"<code>generate_task_call(task_call, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generate the Petri Net components for a Task Call.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>The ids of the last transitions of the TaskCall petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_task_call(\n    self,\n    task_call: TaskCall,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; List[str]:\n    \"\"\"Generate the Petri Net components for a Task Call.\n\n    Returns:\n        The ids of the last transitions of the TaskCall petri net component.\n    \"\"\"\n    called_task = self.tasks[task_call.name]\n    new_task_context = TaskAPI(called_task, task_context, task_call=task_call, in_loop=in_loop)\n\n    group_id = str(uuid.uuid4())\n    task_node = Node(group_id, task_call.name, node)\n\n    task_cluster = Cluster([])\n    node.cluster.add_child(task_cluster)\n    task_node.cluster = task_cluster\n\n    # Order for callbacks important: Task starts before statement and finishes after\n    self.add_callback(first_transition_id, self.callbacks.task_started, new_task_context)\n    last_connection_ids = self.generate_statements(\n        new_task_context,\n        called_task.statements,\n        first_transition_id,\n        second_transition_id,\n        task_node,\n        in_loop,\n    )\n\n    for last_connection_id in last_connection_ids:\n        self.add_callback(last_connection_id, self.callbacks.task_finished, new_task_context)\n\n    return last_connection_ids\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.generate_while_loop","title":"<code>generate_while_loop(loop, task_context, first_transition_id, second_transition_id, node, in_loop=False)</code>","text":"<p>Generate the Petri Net components for a While Loop.</p> <p>Returns:</p> Type Description <code>str</code> <p>The id of the last transition of the WhileLoop petri net component.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def generate_while_loop(\n    self,\n    loop: CountingLoop,\n    task_context: TaskAPI,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n    in_loop: bool = False,\n) -&gt; str:\n    \"\"\"Generate the Petri Net components for a While Loop.\n\n    Returns:\n        The id of the last transition of the WhileLoop petri net component.\n    \"\"\"\n    group_id = str(uuid.uuid4())\n    while_loop_node = Node(group_id, \"While Loop\", node)\n\n    loop_id = create_place(\"Loop\", self.net, group_id)\n\n    loop_text = \"Loop\"\n\n    loop_statements_id = create_place(loop_text, self.net, group_id)\n    loop_finished_id = create_place(\"Number of Steps Done\", self.net, group_id)\n\n    condition_passed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    condition_failed_transition_id = create_transition(\"\", \"\", self.net, group_id)\n    iteration_step_done_transition_id = create_transition(\"\", \"\", self.net, group_id)\n\n    self.net.add_input(loop_id, condition_passed_transition_id, Value(1))\n    self.net.add_input(loop_statements_id, condition_passed_transition_id, Value(1))\n    self.net.add_input(loop_id, condition_failed_transition_id, Value(1))\n    self.net.add_input(loop_finished_id, condition_failed_transition_id, Value(1))\n    self.net.add_output(loop_id, iteration_step_done_transition_id, Value(1))\n\n    loop_done_id = create_place(\"Loop Done\", self.net, group_id)\n\n    cluster = Cluster(\n        [\n            loop_id,\n            loop_statements_id,\n            loop_finished_id,\n            condition_failed_transition_id,\n            loop_done_id,\n            condition_passed_transition_id,\n            iteration_step_done_transition_id,\n        ]\n    )\n\n    node.cluster.add_child(cluster)\n    while_loop_node.cluster = cluster\n    self.generate_statements(\n        task_context,\n        loop.statements,\n        condition_passed_transition_id,\n        iteration_step_done_transition_id,\n        while_loop_node,\n        True,\n    )\n\n    self.net.add_output(loop_id, first_transition_id, Value(1))\n    self.net.add_input(loop_done_id, second_transition_id, Value(1))\n\n    args = (loop, loop_statements_id, loop_finished_id, task_context)\n    self.add_callback(first_transition_id, self.callbacks.while_loop_started, *args)\n    self.add_callback(\n        iteration_step_done_transition_id, self.callbacks.while_loop_started, *args\n    )\n\n    self.net.add_output(loop_done_id, condition_failed_transition_id, Value(1))\n\n    return condition_failed_transition_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.parse_expression","title":"<code>parse_expression(expression)</code>","text":"<p>Parses the given expression to a printable format.</p> <p>Returns:</p> Type Description <code>str</code> <p>The content of the expression as a formatted string.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def parse_expression(self, expression: Dict) -&gt; str:\n    \"\"\"Parses the given expression to a printable format.\n\n    Returns:\n        The content of the expression as a formatted string.\n    \"\"\"\n    if isinstance(expression, (str, int, float, bool)):\n        return str(expression)\n    if isinstance(expression, list):\n        list_string = \"\"\n        for element in expression:\n            if list_string != \"\":\n                list_string = list_string + \".\" + element\n            else:\n                list_string = element\n        return list_string\n    if len(expression) == 2:\n        return \"!\" + self.parse_expression(expression[\"value\"])\n    if expression[\"left\"] == \"(\" and expression[\"right\"] == \")\":\n        return \"(\" + self.parse_expression(expression[\"binOp\"]) + \")\"\n\n    return (\n        self.parse_expression(expression[\"left\"])\n        + expression[\"binOp\"]\n        + self.parse_expression(expression[\"right\"])\n    )\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.PetriNetGenerator.remove_place_on_runtime","title":"<code>remove_place_on_runtime(place_id)</code>","text":"<p>Removes a place from the petri net at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>place_id</code> <code>str</code> <p>The id as string of the task which should be removed from the net.</p> required Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def remove_place_on_runtime(self, place_id: str) -&gt; None:\n    \"\"\"Removes a place from the petri net at runtime.\n\n    Args:\n        place_id: The id as string of the task which should be removed from the net.\n    \"\"\"\n    if self.net.has_place(place_id):\n        # temporary fix\n        # self.net.clusters.remove_node(self.task_started_id)\n        # self.net.remove_place(self.task_started_id)\n\n        if self.draw_net:\n            draw_petri_net(self.net, self.path_for_image)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.create_place","title":"<code>create_place(name, net, group_id, cluster=[])</code>","text":"<p>Utility function for creating a place with the snakes module.</p> <p>This function is used to add a place with the given name and to add labels for scheduling (for example if the place represents an event or if its initialized).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the displayed name of the place.</p> required <code>net</code> <code>PetriNet</code> <p>The petri net instance this place should be added to.</p> required <code>group_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>str</code> <p>A UUID as string for the added place.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def create_place(name: str, net: PetriNet, group_id: str, cluster: List = []) -&gt; str:\n    \"\"\"Utility function for creating a place with the snakes module.\n\n    This function is used to add a place with the given name and to add labels for\n    scheduling (for example if the place represents an event or if its initialized).\n\n    Args:\n        name: A string representing the displayed name of the place.\n        net: The petri net instance this place should be added to.\n        group_id:\n\n    Returns:\n        A UUID as string for the added place.\n    \"\"\"\n    place_id = str(uuid.uuid4())\n    net.add_place(Place(place_id, []), cluster=cluster)\n    net.place(place_id).label(name=name, group_id=group_id)\n    return place_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.generator.create_transition","title":"<code>create_transition(transition_name, transition_type, net, group_id)</code>","text":"<p>Utility function for creating a transition with the snakes module.</p> <p>This function is used to add a transition with the given name and to add labels for scheduling (currently only the type of the transition).</p> <p>Parameters:</p> Name Type Description Default <code>transition_name</code> <code>str</code> <p>A string representing the displayed name of the transition.</p> required <code>net</code> <code>PetriNet</code> <p>The petri net instance this transition should be added to.</p> required <code>group_id</code> <code>str</code> required <p>Returns:</p> Type Description <code>str</code> <p>A UUID as string for the added transition.</p> Source code in <code>pfdl_scheduler/petri_net/generator.py</code> <pre><code>def create_transition(\n    transition_name: str, transition_type: str, net: PetriNet, group_id: str\n) -&gt; str:\n    \"\"\"Utility function for creating a transition with the snakes module.\n\n    This function is used to add a transition with the given name and to add labels for\n    scheduling (currently only the type of the transition).\n\n    Args:\n        transition_name: A string representing the displayed name of the transition.\n        net: The petri net instance this transition should be added to.\n        group_id:\n\n    Returns:\n        A UUID as string for the added transition.\n    \"\"\"\n    transition_id = str(uuid.uuid4())\n    net.add_transition(Transition(transition_id))\n    net.transition(transition_id).label(\n        name=transition_name,\n        transitionType=transition_type,\n        group_id=group_id,\n    )\n    return transition_id\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.logic","title":"<code>logic</code>","text":"<p>Contains the PetriNetLogic class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.logic.PetriNetLogic","title":"<code>PetriNetLogic(petri_net_generator, draw_net=True, file_name='')</code>","text":"<p>Provides methods for interacting with the generated petri nets for scheduling.</p> <p>Scheduling of the production process with the help of the generated petri nets is done in this class.</p> <p>Attributes:</p> Name Type Description <code>petri_net_generator</code> <code>PetriNetGenerator</code> <p>A reference to the PetriNetGenerator.</p> <code>petri_net</code> <code>PetriNet</code> <p>A reference to the generated petri net.</p> <code>draw_net</code> <code>bool</code> <p>Indiciating whether the net should be drawn.</p> <code>transition_dict</code> <code>Dict</code> <p>A reference to the dict in the generator which maps the ids to callbacks.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>petri_net_generator</code> <code>PetriNetGenerator</code> <p>A reference to the PetriNetGenerator.</p> required <code>draw_net</code> <code>bool</code> <p>Indiciating whether the net should be drawn.</p> <code>True</code> Source code in <code>pfdl_scheduler/petri_net/logic.py</code> <pre><code>def __init__(\n    self, petri_net_generator: PetriNetGenerator, draw_net: bool = True, file_name: str = \"\"\n):\n    \"\"\"Initialize the object.\n\n    Args:\n        petri_net_generator: A reference to the PetriNetGenerator.\n        draw_net: Indiciating whether the net should be drawn.\n    \"\"\"\n    self.petri_net_generator: PetriNetGenerator = petri_net_generator\n    self.petri_net: PetriNet = petri_net_generator.net\n    self.draw_net: bool = draw_net\n    self.transition_dict: Dict = self.petri_net_generator.transition_dict\n    self.file_name = file_name\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.logic.PetriNetLogic.draw_petri_net","title":"<code>draw_petri_net()</code>","text":"<p>Saves the given petri net as an image in the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>The name of the image.</p> required <code>petri_net</code> <p>The petri net instance that should be drawn.</p> required Source code in <code>pfdl_scheduler/petri_net/logic.py</code> <pre><code>def draw_petri_net(self) -&gt; None:\n    \"\"\"Saves the given petri net as an image in the current working directory.\n\n    Args:\n        name: The name of the image.\n        petri_net: The petri net instance that should be drawn.\n    \"\"\"\n\n    file_path = \"./temp/\" + self.file_name\n\n    if self.draw_net:\n        draw_petri_net(self.petri_net, file_path)\n        draw_petri_net(self.petri_net, file_path, \".dot\")\n        with open(file_path + \".dot\", \"a\") as file:\n            file.write(\"\\ncall_tree:\")\n            file.write(json.dumps(self.petri_net_generator.tree.toJSON(), indent=4))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.logic.PetriNetLogic.evaluate_petri_net","title":"<code>evaluate_petri_net()</code>","text":"<p>Tries to fire every transition as long as all transitions were tried and nothing can be done anymore.</p> Source code in <code>pfdl_scheduler/petri_net/logic.py</code> <pre><code>def evaluate_petri_net(self) -&gt; None:\n    \"\"\"Tries to fire every transition as long as all transitions\n    were tried and nothing can be done anymore.\n    \"\"\"\n    index = 0\n\n    transitions = list(self.petri_net._trans)\n    while index &lt; len(transitions):\n        transition_id = transitions[index]\n\n        if self.petri_net.transition(transition_id).enabled(Value(1)):\n            if transition_id in self.transition_dict:\n                callbacks = self.transition_dict[transition_id]\n                temp = None\n\n                for callback in callbacks:\n                    # parallel loop functionality stop evaluation\n                    if callback.func.__name__ == \"on_parallel_loop_started\":\n                        temp = callback\n                        callbacks.remove(temp)\n\n                if temp:\n                    for callback in list(callbacks):\n                        callback()\n                        callbacks.remove(callback)\n                    temp()\n                    return\n                else:\n                    self.petri_net.transition(transition_id).fire(Value(1))\n\n                    for callback in callbacks:\n                        callback()\n            else:\n                self.petri_net.transition(transition_id).fire(Value(1))\n\n            index = 0\n        else:\n            index = index + 1\n\n    self.draw_petri_net()\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.petri_net.logic.PetriNetLogic.fire_event","title":"<code>fire_event(event)</code>","text":"<p>Adds a token to the corresponding place of the event in the petri net.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>The Event object that is fired.</p> required Source code in <code>pfdl_scheduler/petri_net/logic.py</code> <pre><code>def fire_event(self, event: Event) -&gt; bool:\n    \"\"\"Adds a token to the corresponding place of the event in the petri net.\n\n    Args:\n        event: The Event object that is fired.\n    \"\"\"\n\n    name_in_petri_net = \"\"\n    if event.event_type == START_PRODUCTION_TASK:\n        name_in_petri_net = self.petri_net_generator.task_started_id\n    elif event.event_type == SET_PLACE:\n        name_in_petri_net = event.data[\"place_id\"]\n    elif event.event_type == SERVICE_FINISHED:\n        name_in_petri_net = self.petri_net_generator.place_dict[event.data[\"service_id\"]]\n\n    if self.petri_net.has_place(name_in_petri_net):\n        self.petri_net.place(name_in_petri_net).add(1)\n        self.draw_petri_net()\n        self.evaluate_petri_net()\n        return True\n\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler","title":"<code>scheduler</code>","text":"<p>Contains the Scheduler class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.ParallelLoopCounter","title":"<code>ParallelLoopCounter()</code>","text":"<p>Represents an intermediate object which indicates that the counter is from a parallel loop.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def __init__(self):\n    self.value = -1\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler","title":"<code>Scheduler(pfdl_file_path, generate_test_ids=False, draw_petri_net=True, scheduler_id='', dashboard_host_address='')</code>","text":"<p>             Bases: <code>Subject</code></p> <p>Schedules Tasks of a given PFDL file.</p> <p>The scheduler comprises almost the complete execution of a production order including the parsing of the PFDL description, model creation and validation and execution of the petri net. It interacts with the execution engines and informs them about services or tasks which started or finished.</p> <p>This class implements the Observer pattern and serves as subject. Observers can be registered in the scheduler and receive updates (e.g. log entries, info about a new petri net img,..)</p> <p>Attributes:</p> Name Type Description <code>running</code> <code>bool</code> <p>A boolean that indicates whether the scheduler is running.</p> <code>pfdl_file_valid</code> <code>bool</code> <p>A boolean indicating whether the given PFDL file was valid.</p> <code>process</code> <code>Process</code> <p>The corresponding Process instance from the PFDL file.</p> <code>petri_net_generator</code> <code>PetriNetGenerator</code> <p>A PetriNetGenerator instance for generating the petri net.</p> <code>petri_net_logic</code> <code>PetriNetLogic</code> <p>A PetriNetLogic instance for execution of the petri net.</p> <code>task_callbacks</code> <code>TaskCallbacks</code> <p>TaskCallbacks instance which holds the registered callbacks.</p> <code>variable_access_function</code> <code>Callable[[str], str]</code> <p>The function which will be called when the scheduler needs a variable.</p> <code>loop_counters</code> <code>Dict[str, Dict[str, int]]</code> <p>A dict for mapping task ids to the current loop counter (counting loops).</p> <code>awaited_events</code> <code>List[Event]</code> <p>A list of awaited <code>Event</code>s. Only these events can be passed to the net.</p> <code>generate_test_ids</code> <code>bool</code> <p>Indicates whether test ids should be generated.</p> <code>test_id_counters</code> <code>List[int]</code> <p>A List consisting of counters for the test ids of tasks and services.</p> <code>observers</code> <code>List[Observer]</code> <p>List of <code>Observers</code> used to update them on a <code>notify</code> call.</p> <p>Initialize the object.</p> <p>If the given path leads to a valid PFDL file the parsing will be started. If no errors occur the model of the PFDL File will be transformed into a petri net and be drawn if the <code>draw_petri_net</code> flag is set. If <code>generate_test_ids</code> is set the ids of the called tasks and services will be an enumeration starting at 0.</p> <p>Parameters:</p> Name Type Description Default <code>pfdl_file_path</code> <code>str</code> <p>The path to the PFDL file.</p> required <code>generate_test_ids</code> <code>bool</code> <p>A boolean indicating whether test ids should be generated.</p> <code>False</code> <code>draw_petri_net</code> <code>bool</code> <p>A boolean indicating whether the petri net should be drawn.</p> <code>True</code> <code>scheduler_id</code> <code>str</code> <p>A unique ID to identify the Scheduer / Production Order</p> <code>''</code> <code>dashboard_host_address</code> <code>str</code> <p>The address of the Dashboard (if existing)</p> <code>''</code> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def __init__(\n    self,\n    pfdl_file_path: str,\n    generate_test_ids: bool = False,\n    draw_petri_net: bool = True,\n    scheduler_id: str = \"\",\n    dashboard_host_address: str = \"\",\n) -&gt; None:\n    \"\"\"Initialize the object.\n\n    If the given path leads to a valid PFDL file the parsing will be started. If no errors\n    occur the model of the PFDL File will be transformed into a petri net and be drawn if\n    the `draw_petri_net` flag is set. If `generate_test_ids` is set the ids of the called\n    tasks and services will be an enumeration starting at 0.\n\n    Args:\n        pfdl_file_path: The path to the PFDL file.\n        generate_test_ids: A boolean indicating whether test ids should be generated.\n        draw_petri_net: A boolean indicating whether the petri net should be drawn.\n        scheduler_id: A unique ID to identify the Scheduer / Production Order\n        dashboard_host_address: The address of the Dashboard (if existing)\n    \"\"\"\n    if scheduler_id == \"\":\n        self.scheduler_id: str = str(uuid.uuid4())\n    else:\n        self.scheduler_id: str = scheduler_id\n    self.running: bool = False\n    self.pfdl_file_valid: bool = False\n    self.process: Process = None\n    self.petri_net_generator: PetriNetGenerator = None\n    self.petri_net_logic: PetriNetLogic = None\n    self.task_callbacks: TaskCallbacks = TaskCallbacks()\n    self.variable_access_function: Callable[[str], str] = None\n    self.loop_counters: Dict[str, Dict[str, int]] = {}\n    self.awaited_events: List[Event] = []\n    self.generate_test_ids: bool = generate_test_ids\n    self.test_id_counters: List[int] = [0, 0]\n    self.pfdl_file_valid, self.process, pfdl_string = parse_file(pfdl_file_path)\n    if self.pfdl_file_valid:\n        self.petri_net_generator = PetriNetGenerator(\n            \"\",\n            generate_test_ids=generate_test_ids,\n            draw_net=draw_petri_net,\n            file_name=self.scheduler_id,\n        )\n        self.register_for_petrinet_callbacks()\n\n        self.petri_net_generator.generate_petri_net(self.process)\n        self.petri_net_logic = PetriNetLogic(\n            self.petri_net_generator, draw_petri_net, file_name=self.scheduler_id\n        )\n\n    awaited_event = Event(event_type=START_PRODUCTION_TASK, data={})\n    self.awaited_events.append(awaited_event)\n    self.observers: List[Observer] = []\n\n    # enable logging\n    self.attach(LogEntryObserver(self.scheduler_id))\n\n    if dashboard_host_address != \"\":\n        self.attach(DashboardObserver(dashboard_host_address, self.scheduler_id, pfdl_string))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.attach","title":"<code>attach(observer)</code>","text":"<p>Attach (add) an observer object to the observers list.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def attach(self, observer: Observer) -&gt; None:\n    \"\"\"Attach (add) an observer object to the observers list.\"\"\"\n    self.observers.append(observer)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.check_expression","title":"<code>check_expression(expression, task_context)</code>","text":"<p>Check the boolean value of the given PFDL expression as a Python expression.</p> <p>This method only gets executed if the semantic error check is passed. This means that no additional semantic checks has to be performed.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Dict</code> <p>A dict representing the expression.</p> required <code>task_context</code> <code>TaskAPI</code> <p>The context in which the expression should be evaluated.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>The value of the successfully executed expression in Python as a bool.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def check_expression(self, expression: Dict, task_context: TaskAPI) -&gt; bool:\n    \"\"\"Check the boolean value of the given PFDL expression as a Python expression.\n\n    This method only gets executed if the semantic error check is passed. This means that\n    no additional semantic checks has to be performed.\n\n    Arguments:\n        expression: A dict representing the expression.\n        task_context: The context in which the expression should be evaluated.\n\n    Returns:\n        The value of the successfully executed expression in Python as a bool.\n    \"\"\"\n    return bool(self.execute_expression(expression, task_context))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.detach","title":"<code>detach(observer)</code>","text":"<p>Detach (remove) an observer object from the observers list.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def detach(self, observer: Observer) -&gt; None:\n    \"\"\"Detach (remove) an observer object from the observers list.\"\"\"\n    self.observers.remove(observer)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.execute_expression","title":"<code>execute_expression(expression, task_context)</code>","text":"<p>Executes the given PFDL expression as a Python expression.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Dict</code> <p>A dict representing the expression.</p> required <code>task_context</code> <code>TaskAPI</code> <p>The context in which the expression should be evaluated.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value of the expression executed in Python (type depends on specific expression).</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def execute_expression(self, expression: Dict, task_context: TaskAPI) -&gt; Any:\n    \"\"\"Executes the given PFDL expression as a Python expression.\n\n    Arguments:\n        expression: A dict representing the expression.\n        task_context: The context in which the expression should be evaluated.\n\n    Returns:\n        The value of the expression executed in Python (type depends on specific expression).\n    \"\"\"\n    if isinstance(expression, (str, int, float, bool)):\n        return expression\n    if isinstance(expression, list):\n        variable_name = expression[0]\n        variable = self.variable_access_function(variable_name, task_context)\n\n        for i in range(1, len(expression)):\n            variable = variable.attributes[expression[i]]\n        return variable\n    if len(expression) == 2:\n        return not self.execute_expression(expression[\"value\"], task_context)\n\n    if expression[\"left\"] == \"(\" and expression[\"right\"] == \")\":\n        return self.execute_expression(expression[\"binOp\"], task_context)\n\n    left_side = self.execute_expression(expression[\"left\"], task_context)\n    right_side = self.execute_expression(expression[\"right\"], task_context)\n\n    op_func = helpers.parse_operator(expression[\"binOp\"])\n    return op_func(left_side, right_side)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.fire_event","title":"<code>fire_event(event)</code>","text":"<p>Forwards the given Event to the PetriNetLogic instance.</p> <p>The given <code>Event</code> object will be passed to the petri net if it is an awaited event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An <code>Event</code> instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the event could be fired to the petri net (is an awaited event).</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def fire_event(self, event: Event) -&gt; bool:\n    \"\"\"Forwards the given Event to the PetriNetLogic instance.\n\n    The given `Event` object will be passed to the petri net if it is an awaited\n    event.\n\n    Args:\n        event: An `Event` instance.\n\n    Returns:\n        True if the event could be fired to the petri net (is an awaited event).\n    \"\"\"\n\n    if event in self.awaited_events:\n        if self.petri_net_logic.fire_event(event):\n            self.awaited_events.remove(event)\n            self.notify(NotificationType.PETRI_NET, self.scheduler_id)\n            return True\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.notify","title":"<code>notify(notification_type, data)</code>","text":"<p>Trigger an update in each subscriber.</p> <p>Parameters:</p> Name Type Description Default <code>notification_type</code> <code>NotificationType</code> <p>A <code>NotificationType</code> informs about the type of the data.</p> required <code>data</code> <code>Any</code> <p>The data which the observers will receive.</p> required Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def notify(self, notification_type: NotificationType, data: Any) -&gt; None:\n    \"\"\"Trigger an update in each subscriber.\n\n    Args:\n        notification_type: A `NotificationType` informs about the type of the data.\n        data: The data which the observers will receive.\n    \"\"\"\n\n    for observer in self.observers:\n        observer.update(notification_type, data)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_condition_started","title":"<code>on_condition_started(condition, then_uuid, else_uuid, task_context)</code>","text":"<p>Executes Scheduling logic when a Condition statement is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_condition_started(\n    self, condition: Condition, then_uuid: str, else_uuid: str, task_context: TaskAPI\n) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Condition statement is started.\"\"\"\n    if self.check_expression(condition.expression, task_context):\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": then_uuid})\n        self.awaited_events.append(awaited_event)\n        self.fire_event(awaited_event)\n    else:\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": else_uuid})\n        self.awaited_events.append(awaited_event)\n        self.fire_event(awaited_event)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_counting_loop_started","title":"<code>on_counting_loop_started(loop, then_uuid, else_uuid, task_context)</code>","text":"<p>Executes Scheduling logic when a Counting Loop is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_counting_loop_started(\n    self, loop: CountingLoop, then_uuid: str, else_uuid: str, task_context: TaskAPI\n) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Counting Loop is started.\"\"\"\n\n    if self.loop_counters.get(task_context.uuid) is None:\n        self.loop_counters[task_context.uuid] = {}\n\n    if self.loop_counters[task_context.uuid].get(loop) is None:\n        self.loop_counters[task_context.uuid][loop] = 0\n    else:\n        self.loop_counters[task_context.uuid][loop] = (\n            self.loop_counters[task_context.uuid][loop] + 1\n        )\n\n    loop_counter = self.loop_counters[task_context.uuid][loop]\n    loop_limit = self.get_loop_limit(loop, task_context)\n\n    if loop_counter &lt; loop_limit:\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": then_uuid})\n        self.awaited_events.append(awaited_event)\n\n        self.fire_event(awaited_event)\n    else:\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": else_uuid})\n        self.awaited_events.append(awaited_event)\n\n        # has to be executed at last\n        self.fire_event(awaited_event)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_parallel_loop_started","title":"<code>on_parallel_loop_started(loop, task_context, parallelTask, parallel_loop_started, first_transition_id, second_transition_id, node)</code>","text":"<p>Executes Scheduling logic when a Parallel Loop is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_parallel_loop_started(\n    self,\n    loop: CountingLoop,\n    task_context: TaskAPI,\n    parallelTask: Task,\n    parallel_loop_started,\n    first_transition_id: str,\n    second_transition_id: str,\n    node: Node,\n) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Parallel Loop is started.\"\"\"\n    task_count = self.get_loop_limit(loop, task_context)\n\n    # generate parallel tasks in petri net\n    if task_count &gt; 0:\n        for i in range(int(task_count)):\n            self.petri_net_generator.generate_task_call(\n                parallelTask,\n                task_context,\n                first_transition_id,\n                second_transition_id,\n                node,\n                False,\n            )\n\n            if self.loop_counters.get(task_context.uuid) is None:\n                self.loop_counters[task_context.uuid] = {}\n            self.loop_counters[task_context.uuid][\n                loop.counting_variable\n            ] = ParallelLoopCounter()\n    else:\n        self.petri_net_generator.generate_empty_parallel_loop(\n            first_transition_id, second_transition_id\n        )\n\n    self.petri_net_generator.remove_place_on_runtime(parallel_loop_started)\n\n    # start evaluation of net again\n    self.petri_net_logic.evaluate_petri_net()\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_service_finished","title":"<code>on_service_finished(service_api)</code>","text":"<p>Executes Scheduling logic when a Service is finished.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_service_finished(self, service_api: ServiceAPI) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Service is finished.\"\"\"\n    for callback in self.task_callbacks.service_finished:\n        callback(service_api)\n\n    log_entry = (\n        \"Service \"\n        + service_api.service.name\n        + \" with UUID '\"\n        + service_api.uuid\n        + \"' finished.\"\n    )\n    self.notify(NotificationType.LOG_EVENT, (log_entry, logging.INFO, False))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_service_started","title":"<code>on_service_started(service_api)</code>","text":"<p>Executes Scheduling logic when a Service is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_service_started(self, service_api: ServiceAPI) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Service is started.\"\"\"\n\n    new_uuid = str(uuid.uuid4())\n    if self.generate_test_ids:\n        new_uuid = str(self.test_id_counters[1])\n        self.test_id_counters[1] = self.test_id_counters[1] + 1\n    self.petri_net_generator.place_dict[new_uuid] = self.petri_net_generator.place_dict[\n        service_api.uuid\n    ]\n\n    service_api.uuid = new_uuid\n    if service_api.input_parameters:\n        service_api.input_parameters = copy.deepcopy(service_api.service.input_parameters)\n\n    awaited_event = Event(event_type=SERVICE_FINISHED, data={\"service_id\": service_api.uuid})\n    self.awaited_events.append(awaited_event)\n\n    self.substitute_loop_indexes(service_api)\n    for callback in self.task_callbacks.service_started:\n        callback(service_api)\n\n    log_entry = (\n        \"Service \" + service_api.service.name + \" with UUID '\" + service_api.uuid + \"' started.\"\n    )\n    self.notify(NotificationType.LOG_EVENT, (log_entry, logging.INFO, False))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_task_finished","title":"<code>on_task_finished(task_api)</code>","text":"<p>Executes Scheduling logic when a Task is finished.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_task_finished(self, task_api: TaskAPI) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Task is finished.\"\"\"\n    for callback in self.task_callbacks.task_finished:\n        callback(task_api)\n\n    order_finished = False\n    if task_api.task.name == \"productionTask\":\n        self.running = False\n        order_finished = True\n        self.petri_net_logic.draw_petri_net()\n        self.notify(NotificationType.PETRI_NET, self.scheduler_id)\n\n    log_entry = \"Task \" + task_api.task.name + \" with UUID '\" + task_api.uuid + \"' finished.\"\n    self.notify(NotificationType.LOG_EVENT, (log_entry, logging.INFO, order_finished))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_task_started","title":"<code>on_task_started(task_api)</code>","text":"<p>Executes Scheduling logic when a Task is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_task_started(self, task_api: TaskAPI) -&gt; None:\n    \"\"\"Executes Scheduling logic when a Task is started.\"\"\"\n    new_uuid = str(uuid.uuid4())\n    if self.generate_test_ids:\n        new_uuid = str(self.test_id_counters[0])\n        self.test_id_counters[0] = self.test_id_counters[0] + 1\n\n    task_api.uuid = new_uuid\n    if task_api.task_call:\n        task_api.input_parameters = copy.deepcopy(task_api.task_call.input_parameters)\n\n    self.substitute_loop_indexes(task_api)\n    for callback in self.task_callbacks.task_started:\n        callback(task_api)\n\n    log_entry = \"Task \" + task_api.task.name + \" with UUID '\" + task_api.uuid + \"' started.\"\n    self.notify(NotificationType.LOG_EVENT, (log_entry, logging.INFO, False))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.on_while_loop_started","title":"<code>on_while_loop_started(loop, then_uuid, else_uuid, task_context)</code>","text":"<p>Executes Scheduling logic when a While Loop is started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def on_while_loop_started(\n    self, loop: WhileLoop, then_uuid: str, else_uuid: str, task_context: TaskAPI\n) -&gt; None:\n    \"\"\"Executes Scheduling logic when a While Loop is started.\"\"\"\n    if self.check_expression(loop.expression, task_context):\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": then_uuid})\n        self.awaited_events.append(awaited_event)\n        self.fire_event(awaited_event)\n    else:\n        awaited_event = Event(event_type=SET_PLACE, data={\"place_id\": else_uuid})\n        self.awaited_events.append(awaited_event)\n        self.fire_event(awaited_event)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_callback_service_finished","title":"<code>register_callback_service_finished(callback)</code>","text":"<p>Registers the given callback in the service_finished list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ServiceAPI], Any]</code> <p>Function which will be invoked when a Service is finished.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_callback_service_finished(self, callback: Callable[[ServiceAPI], Any]) -&gt; bool:\n    \"\"\"Registers the given callback in the service_finished list.\n\n    Args:\n        callback: Function which will be invoked when a Service is finished.\n\n    Returns:\n        True if the callback was successfully registered.\n    \"\"\"\n    if callback not in self.task_callbacks.service_finished:\n        self.task_callbacks.service_finished.append(callback)\n        return True\n\n    print(\"The given Callback function is already registered!\")\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_callback_service_started","title":"<code>register_callback_service_started(callback)</code>","text":"<p>Registers the given callback in the service_started list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ServiceAPI], Any]</code> <p>Function which will be invoked when a Service is started.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_callback_service_started(self, callback: Callable[[ServiceAPI], Any]) -&gt; bool:\n    \"\"\"Registers the given callback in the service_started list.\n\n    Args:\n        callback: Function which will be invoked when a Service is started.\n\n    Returns:\n        True if the callback was successfully registered.\n    \"\"\"\n    if callback not in self.task_callbacks.service_started:\n        self.task_callbacks.service_started.append(callback)\n        return True\n\n    print(\"The given Callback function is already registered!\")\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_callback_task_finished","title":"<code>register_callback_task_finished(callback)</code>","text":"<p>Registers the given callback in the task_finished list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TaskAPI], Any]</code> <p>Function which will be invoked when a Task is finished.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_callback_task_finished(self, callback: Callable[[TaskAPI], Any]) -&gt; bool:\n    \"\"\"Registers the given callback in the task_finished list.\n\n    Args:\n        callback: Function which will be invoked when a Task is finished.\n\n    Returns:\n        True if the callback was successfully registered.\n    \"\"\"\n    if callback not in self.task_callbacks.task_finished:\n        self.task_callbacks.task_finished.append(callback)\n        return True\n\n    print(\"The given Callback function is already registered!\")\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_callback_task_started","title":"<code>register_callback_task_started(callback)</code>","text":"<p>Registers the given callback in the task_started list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TaskAPI], Any]</code> <p>Function which will be invoked when a Task is started.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_callback_task_started(self, callback: Callable[[TaskAPI], Any]) -&gt; bool:\n    \"\"\"Registers the given callback in the task_started list.\n\n    Args:\n        callback: Function which will be invoked when a Task is started.\n\n    Returns:\n        True if the callback was successfully registered.\n    \"\"\"\n    if callback not in self.task_callbacks.task_started:\n        self.task_callbacks.task_started.append(callback)\n        return True\n\n    print(\"The given Callback function is already registered!\")\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_for_petrinet_callbacks","title":"<code>register_for_petrinet_callbacks()</code>","text":"<p>Register scheduler callback functions in the petri net.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_for_petrinet_callbacks(self) -&gt; None:\n    \"\"\"Register scheduler callback functions in the petri net.\"\"\"\n    callbacks = self.petri_net_generator.callbacks\n    callbacks.task_started = self.on_task_started\n    callbacks.service_started = self.on_service_started\n    callbacks.service_finished = self.on_service_finished\n    callbacks.condition_started = self.on_condition_started\n    callbacks.while_loop_started = self.on_while_loop_started\n    callbacks.counting_loop_started = self.on_counting_loop_started\n    callbacks.parallel_loop_started = self.on_parallel_loop_started\n    callbacks.task_finished = self.on_task_finished\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.register_variable_access_function","title":"<code>register_variable_access_function(var_access_func)</code>","text":"<p>Registers the given callback as the variable acces function of the Scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>var_access_func</code> <code>Callable[[str], str]</code> <p>The function which will be called when the scheduler needs a variable.</p> required Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def register_variable_access_function(self, var_access_func: Callable[[str], str]) -&gt; None:\n    \"\"\"Registers the given callback as the variable acces function of the Scheduler.\n\n    Args:\n        var_access_func: The function which will be called when the scheduler needs a variable.\n    \"\"\"\n    self.variable_access_function = var_access_func\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.start","title":"<code>start()</code>","text":"<p>Starts the scheduling process for the given PFDL file from the path.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the corresponding PFDL file was valid and the Scheduler could be started.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def start(self) -&gt; bool:\n    \"\"\"Starts the scheduling process for the given PFDL file from the path.\n\n    Returns:\n        True if the corresponding PFDL file was valid and the Scheduler could be started.\n    \"\"\"\n    if self.pfdl_file_valid:\n        self.fire_event(Event(event_type=START_PRODUCTION_TASK, data={}))\n        self.running = True\n        return True\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduler.Scheduler.substitute_loop_indexes","title":"<code>substitute_loop_indexes(call_api)</code>","text":"<p>Substitutes loop indexes in service or task call input parameters if present.</p> Source code in <code>pfdl_scheduler/scheduler.py</code> <pre><code>def substitute_loop_indexes(self, call_api: Union[ServiceAPI, TaskAPI]) -&gt; None:\n    \"\"\"Substitutes loop indexes in service or task call input parameters if present.\"\"\"\n    if call_api.task_context:\n        task_uuid = call_api.task_context.uuid\n        if task_uuid in self.loop_counters:\n            current_loop_counters = self.loop_counters[task_uuid]\n\n            counter_was_raised = {}\n            for i, input_parameter in enumerate(call_api.input_parameters):\n                if isinstance(input_parameter, List):\n                    for j, element in enumerate(input_parameter):\n                        counting_variable = element.replace(\"[\", \"\").replace(\"]\", \"\")\n                        if counting_variable in current_loop_counters:\n                            value = current_loop_counters[counting_variable]\n                            if isinstance(value, ParallelLoopCounter):\n                                if counting_variable not in counter_was_raised:\n                                    current_loop_counters[counting_variable].value += 1\n                                    counter_was_raised[counting_variable] = True\n                                value = current_loop_counters[counting_variable].value\n                            # substitute the counting variable with the value of the ith iteration\n                            call_api.input_parameters[i][j] = \"[\" + str(value) + \"]\"\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling","title":"<code>scheduling</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling.event","title":"<code>event</code>","text":"<p>Contains the Event class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling.event.Event","title":"<code>Event(event_type='', data=None)</code>","text":"<p>Data class for controlling the PetriNet instance.</p> Currently avaiable Events <ul> <li>Event(event_type=\"service_finished\", data={\"service_id\": }) <p>Attributes:</p> Name Type Description <code>event_type</code> <code>str</code> <p>A string representing the type of the event.</p> <code>data</code> <code>Dict</code> <p>A dict containing the corresponding data of the event type.</p> Source code in <code>pfdl_scheduler/scheduling/event.py</code> <pre><code>def __init__(self, event_type: str = \"\", data: Dict = None) -&gt; None:\n    self.event_type: str = event_type\n    self.data: Dict = data\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling.event.Event.from_json","title":"<code>from_json(json_string)</code>  <code>classmethod</code>","text":"<p>Creates an Event instance out of the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_string</code> <code>str</code> <p>A JSON string desribing the Event.</p> required <p>Returns:</p> Type Description <code>Union[None, Event]</code> <p>The Event which was created from the JSON string. None if the conversion failed.</p> Source code in <code>pfdl_scheduler/scheduling/event.py</code> <pre><code>@classmethod\ndef from_json(cls, json_string: str) -&gt; Union[None, \"Event\"]:\n    \"\"\"Creates an Event instance out of the given JSON string.\n\n    Args:\n        json_string: A JSON string desribing the Event.\n\n    Returns:\n        The Event which was created from the JSON string. None if the conversion failed.\n    \"\"\"\n    json_dict = json.loads(json_string)\n    if \"event_type\" in json_dict and \"data\" in json_dict:\n        return Event(event_type=json_dict[\"event_type\"], data=json_dict[\"data\"])\n    else:\n        return None\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling.task_callbacks","title":"<code>task_callbacks</code>","text":"<p>Contains the TaskCallbacks class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.scheduling.task_callbacks.TaskCallbacks","title":"<code>TaskCallbacks()</code>  <code>dataclass</code>","text":"<p>Contains lists of callback functions that where registered in the scheduler.</p> <p>Attributes:</p> Name Type Description <code>task_started</code> <code>List[Callable[[TaskAPI], Any]]</code> <p>A list of callback functions which get called when a task is started.</p> <code>service_started</code> <code>List[Callable[[ServiceAPI], Any]]</code> <p>A list of callback functions which get called when a service is started.</p> <code>service_finished</code> <code>List[Callable[[ServiceAPI], Any]]</code> <p>A list of callback functions which get called when a service is finished.</p> <code>task_finished</code> <code>List[Callable[[TaskAPI], Any]]</code> <p>A list of callback functions which get called when a task is finished.</p> <p>Initialize the object.</p> Source code in <code>pfdl_scheduler/scheduling/task_callbacks.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the object.\"\"\"\n    self.task_started: List[Callable[[TaskAPI], Any]] = []\n    self.service_started: List[Callable[[ServiceAPI], Any]] = []\n    self.service_finished: List[Callable[[ServiceAPI], Any]] = []\n    self.task_finished: List[Callable[[TaskAPI], Any]] = []\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils","title":"<code>utils</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.dashboard_observer","title":"<code>dashboard_observer</code>","text":"<p>Contains the start up script for the dashboard.</p> <p>A program executed in the VS Code extension which has a string containing a PFDL program as input.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.dashboard_observer.DashboardObserver","title":"<code>DashboardObserver(host, scheduler_id, pfdl_string)</code>","text":"<p>             Bases: <code>Observer</code></p> <p>DashboardObserver for receiving infos about changes of the PetriNet or Scheduling.</p> <p>The Observer will send a post request to the dashboard with the data.</p> Source code in <code>pfdl_scheduler/utils/dashboard_observer.py</code> <pre><code>def __init__(self, host: str, scheduler_id: str, pfdl_string: str) -&gt; None:\n    self.host: str = host\n    self.scheduler_id: str = scheduler_id\n    current_timestamp: int = int(round(datetime.timestamp(datetime.now())))\n    self.starting_date: int = current_timestamp\n    self.pfdl_string: str = pfdl_string\n    self.order_finished: bool = False\n\n    threading.Thread(target=send_post_requests, daemon=True).start()\n\n    request_data = {\n        \"order_id\": scheduler_id,\n        \"starting_date\": current_timestamp,\n        \"last_update\": current_timestamp,\n        \"status\": ORDER_STARTED,\n        \"pfdl_string\": self.pfdl_string,\n    }\n\n    message_queue.put((self.host + ORDER_ROUTE, request_data))\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers","title":"<code>helpers</code>","text":"<p>Helper functions used in the project (especially in the SemanticErrorChecker).</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.check_type_of_value","title":"<code>check_type_of_value(value, value_type)</code>","text":"<p>Checks if the given value is the given type in the DSL.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the value is from the given value type.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def check_type_of_value(value: Any, value_type: str) -&gt; bool:\n    \"\"\"Checks if the given value is the given type in the DSL.\n\n    Returns:\n        True if the value is from the given value type.\n    \"\"\"\n    if value_type == \"number\":\n        # bool is a subclass of int so check it before\n        if isinstance(value, bool):\n            return False\n        return isinstance(value, (int, float))\n    if value_type == \"boolean\":\n        return isinstance(value, bool)\n    if value_type == \"string\":\n        return isinstance(value, str)\n    if isinstance(value, Struct):\n        return value.name == value_type\n    # value was a string\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.get_type_of_variable_list","title":"<code>get_type_of_variable_list(var_list, task, struct_definitions)</code>","text":"<p>Iterates over the given variable list and gets the type of the last element.</p> <p>Returns:</p> Type Description <code>str</code> <p>Type of the last element in the variable list as string.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def get_type_of_variable_list(\n    var_list: List[str], task: Task, struct_definitions: Dict[str, Struct]\n) -&gt; str:\n    \"\"\"Iterates over the given variable list and gets the type of the last element.\n\n    Returns:\n        Type of the last element in the variable list as string.\n    \"\"\"\n    current_struct = struct_definitions[task.variables[var_list[0]]]\n    for i in range(1, len(var_list) - 1):\n        current_struct = struct_definitions[current_struct.attributes[var_list[i]]]\n    variable_type = current_struct.attributes[var_list[len(var_list) - 1]]\n    return variable_type\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_boolean","title":"<code>is_boolean(string)</code>","text":"<p>Checks if the given string can be casted to a boolean.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string can be casted to a boolean.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_boolean(string: str) -&gt; bool:\n    \"\"\"Checks if the given string can be casted to a boolean.\n\n    Returns:\n        True if the given string can be casted to a boolean.\n    \"\"\"\n    if string in (\"true\", \"false\"):\n        return True\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_con","title":"<code>is_con(string)</code>","text":"<p>Checks if the given string is a condition element in the PFDL.</p> <p>A condition element can be a PFDL string, boolean or number</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string is a condition element in the PFDL.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_con(string: str) -&gt; bool:\n    \"\"\"Checks if the given string is a condition element in the PFDL.\n\n    A condition element can be a PFDL string, boolean or number\n\n    Returns:\n        True if the given string is a condition element in the PFDL.\n    \"\"\"\n    return is_string(string) or is_boolean(string) or is_number(string)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_float","title":"<code>is_float(string)</code>","text":"<p>Checks if the given string can be casted to a float.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string can be casted to a float.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_float(string: str) -&gt; bool:\n    \"\"\"Checks if the given string can be casted to a float.\n\n    Returns:\n        True if the given string can be casted to a float.\n    \"\"\"\n    try:\n        float(string)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_int","title":"<code>is_int(string)</code>","text":"<p>Checks if the given string can be casted to an integer.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string can be casted to an integer.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_int(string: str) -&gt; bool:\n    \"\"\"Checks if the given string can be casted to an integer.\n\n    Returns:\n        True if the given string can be casted to an integer.\n    \"\"\"\n    try:\n        int(string)\n    except (TypeError, ValueError):\n        return False\n    else:\n        return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_number","title":"<code>is_number(string)</code>","text":"<p>Checks if the given string can be casted to a number (int or float).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string can be casted to a number.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_number(string: str) -&gt; bool:\n    \"\"\"Checks if the given string can be casted to a number (int or float).\n\n    Returns:\n        True if the given string can be casted to a number.\n    \"\"\"\n    if is_float(string) or is_int(string):\n        return True\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.is_string","title":"<code>is_string(string)</code>","text":"<p>Check if the given parameter is a string in the DSL: It should start and end with '\"'.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given string is a string in the DSL.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def is_string(string: str) -&gt; bool:\n    \"\"\"Check if the given parameter is a string in the DSL: It should start and end with '\"'.\n\n    Returns:\n        True if the given string is a string in the DSL.\n    \"\"\"\n    if isinstance(string, str) and string.startswith('\"') and string.endswith('\"'):\n        return True\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.helpers.parse_operator","title":"<code>parse_operator(op)</code>","text":"<p>Parses a PFDL operator in form of a string into a Python executable operator func.</p> Source code in <code>pfdl_scheduler/utils/helpers.py</code> <pre><code>def parse_operator(op: str) -&gt; operator:\n    \"\"\"Parses a PFDL operator in form of a string into a Python executable operator func.\"\"\"\n    ops = {\n        \"&gt;\": operator.gt,\n        \"&gt;=\": operator.ge,\n        \"&lt;\": operator.lt,\n        \"&lt;=\": operator.le,\n        \"==\": operator.eq,\n        \"!=\": operator.ne,\n        \"And\": operator.and_,\n        \"Or\": operator.or_,\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n    }\n    return ops[op]\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.log_entry_observer","title":"<code>log_entry_observer</code>","text":"<p>This module provides the LogEntryObserver which implements the Observer pattern.</p> <p>The scheduler notifies about log entries, so this class is used to catch these updates and log them into a file</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.log_entry_observer.LogEntryObserver","title":"<code>LogEntryObserver(scheduler_id)</code>","text":"<p>             Bases: <code>Observer</code></p> <p>LogEntryObserver for receiving logging information from the Scheduler.</p> <p>LogLevels are based of https://docs.python.org/3/library/logging.html#logging-levels</p> Source code in <code>pfdl_scheduler/utils/log_entry_observer.py</code> <pre><code>def __init__(self, scheduler_id: str):\n    logging.basicConfig(\n        filename=LOG_FILE_LOCATION + scheduler_id + LOG_FILE_FORMAT,\n        encoding=LOG_FILE_ENCODING,\n        level=logging.DEBUG,\n        filemode=LOG_FILE_FILEMODE,\n    )\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.parsing_utils","title":"<code>parsing_utils</code>","text":"<p>Contains functions which are used to load and parse PFDL files.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.parsing_utils.load_file","title":"<code>load_file(file_path)</code>","text":"<p>Loads the content of the file from the given path.</p> <p>Returns:</p> Type Description <code>str</code> <p>The content of the file as a string.</p> Source code in <code>pfdl_scheduler/utils/parsing_utils.py</code> <pre><code>def load_file(file_path: str) -&gt; str:\n    \"\"\"Loads the content of the file from the given path.\n\n    Returns:\n        The content of the file as a string.\n    \"\"\"\n    pfdl_string = \"\"\n    with open(file_path, \"r\", encoding=\"utf-8\") as file:\n        pfdl_string = file.read()\n    return pfdl_string\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.parsing_utils.parse_file","title":"<code>parse_file(file_path)</code>","text":"<p>Loads the content of the file from the given path and calls the parse_string function.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the PFDL file.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolan indicating validity of the PFDL file, the content of the file, and the</p> <code>Union[None, Process]</code> <p>process object if so, otherwise None.</p> Source code in <code>pfdl_scheduler/utils/parsing_utils.py</code> <pre><code>def parse_file(file_path: str) -&gt; Tuple[bool, Union[None, Process], str]:\n    \"\"\"Loads the content of the file from the given path and calls the parse_string function.\n\n    Args:\n        file_path: The path to the PFDL file.\n\n    Returns:\n        A boolan indicating validity of the PFDL file, the content of the file, and the\n        process object if so, otherwise None.\n    \"\"\"\n    pfdl_string = load_file(file_path)\n    return *parse_string(pfdl_string, file_path), pfdl_string\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.parsing_utils.parse_string","title":"<code>parse_string(pfdl_string, file_path='', used_in_extension=False)</code>","text":"<p>Instantiate the ANTLR lexer and parser and parses the given PFDL string.</p> <p>Parameters:</p> Name Type Description Default <code>pfdl_string</code> <code>str</code> <p>A string containing the content of a PFDL file.</p> required <code>file_path</code> <code>str</code> <p>The path of the PFDL file (used for error messages).</p> <code>''</code> <code>used_in_extension</code> <code>bool</code> <p>A boolean indicating if the function is called from the extension.</p> <code>False</code> <p>Returns:</p> Type Description <code>Tuple[bool, Union[None, Process]]</code> <p>A boolan indicating validity of the PFDL file and the process object if so, otherwise None.</p> Source code in <code>pfdl_scheduler/utils/parsing_utils.py</code> <pre><code>def parse_string(\n    pfdl_string: str, file_path: str = \"\", used_in_extension: bool = False\n) -&gt; Tuple[bool, Union[None, Process]]:\n    \"\"\"Instantiate the ANTLR lexer and parser and parses the given PFDL string.\n\n    Arguments:\n        pfdl_string: A string containing the content of a PFDL file.\n        file_path: The path of the PFDL file (used for error messages).\n        used_in_extension: A boolean indicating if the function is called from the extension.\n\n    Returns:\n        A boolan indicating validity of the PFDL file and the process object if so, otherwise None.\n    \"\"\"\n    lexer = PFDLLexer(InputStream(pfdl_string))\n    lexer.removeErrorListeners()\n\n    token_stream = CommonTokenStream(lexer)\n\n    parser = PFDLParser(token_stream)\n    parser.removeErrorListeners()\n\n    error_handler = ErrorHandler(file_path, used_in_extension)\n    error_listener = SyntaxErrorListener(token_stream, error_handler)\n    parser.addErrorListener(error_listener)\n\n    tree = parser.program()\n\n    if error_handler.has_error() is False:\n        visitor = PFDLTreeVisitor(error_handler)\n        process = visitor.visit(tree)\n\n        semantic_error_checker = SemanticErrorChecker(error_handler, process)\n        semantic_error_checker.validate_process()\n\n        if error_handler.has_error() is False:\n            return (True, process)\n        return (False, process)\n    return (False, None)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.utils.parsing_utils.write_tokens_to_file","title":"<code>write_tokens_to_file(token_stream)</code>","text":"<p>Writes the given ANTLR CommonTokenStream into a file named 'token.txt'.</p> Source code in <code>pfdl_scheduler/utils/parsing_utils.py</code> <pre><code>def write_tokens_to_file(token_stream: CommonTokenStream) -&gt; None:\n    \"\"\"Writes the given ANTLR CommonTokenStream into a file named 'token.txt'.\"\"\"\n    Path(\"./temp\").mkdir(parents=True, exist_ok=True)\n    with open(\"temp/token.txt\", \"w\", encoding=\"utf-8\") as file:\n        pattern = re.compile(\"\\r?\\n.*\")\n        for token in token_stream.tokens:\n            token_text = token.text\n            if re.match(pattern, token.text):\n                token_text = \"NL\"\n            file.write(token_text + \"\\n\")\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation","title":"<code>validation</code>","text":""},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.error_handler","title":"<code>error_handler</code>","text":"<p>Contains the ErrorHandler class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.error_handler.ErrorHandler","title":"<code>ErrorHandler(file_path, used_in_extension)</code>","text":"<p>Keeps track of the total error amount in an PFDL file.</p> <p>Provides a method for printing an erro which counts the errors.</p> <p>Attributes:</p> Name Type Description <code>total_error_count</code> <code>int</code> <p>Total number of errors.</p> <code>syntax_error_count</code> <code>int</code> <p>Number of syntax errors.</p> <code>semantic_error_count</code> <code>int</code> <p>Number of static semantic errors.</p> <code>file_path</code> <code>str</code> <p>The file path to the PFDL file.</p> <code>used_in_extension</code> <code>bool</code> <p>A boolean indicating if the Generator is used within the extension.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The file path to the PFDL file.</p> required <code>used_in_extension</code> <code>bool</code> <p>A boolean indicating if the Generator is used within the extension.</p> required Source code in <code>pfdl_scheduler/validation/error_handler.py</code> <pre><code>def __init__(self, file_path: str, used_in_extension: bool) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        file_path: The file path to the PFDL file.\n        used_in_extension: A boolean indicating if the Generator is used within the extension.\n    \"\"\"\n    self.total_error_count: int = 0\n    self.syntax_error_count: int = 0\n    self.semantic_error_count: int = 0\n    self.file_path: str = file_path\n    self.used_in_extension: bool = used_in_extension\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.error_handler.ErrorHandler.has_error","title":"<code>has_error()</code>","text":"<p>Returns true if the total error_count is greater than zero.</p> Source code in <code>pfdl_scheduler/validation/error_handler.py</code> <pre><code>def has_error(self) -&gt; bool:\n    \"\"\"Returns true if the total error_count is greater than zero.\"\"\"\n    return self.total_error_count &gt; 0\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.error_handler.ErrorHandler.print_error","title":"<code>print_error(error_msg, line=0, column=0, off_symbol_length=0, context=None, syntax_error=False)</code>","text":"<p>Prints an error into the standard output.</p> <p>Parameters:</p> Name Type Description Default <code>error_msg</code> <code>str</code> <p>A string containing the error message</p> required <code>line</code> <code>int</code> <p>The line in which the error occured</p> <code>0</code> <code>column</code> <code>int</code> <p>The column in which the error occured</p> <code>0</code> <code>off_symbol_length</code> <code>int</code> <p>Length of the offending symbol</p> <code>0</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR Context object (lines and column will be used from this if not None)</p> <code>None</code> <code>syntax_error</code> <code>bool</code> <p>A boolean indicating whether the error is a syntax error or not.</p> <code>False</code> Source code in <code>pfdl_scheduler/validation/error_handler.py</code> <pre><code>def print_error(\n    self,\n    error_msg: str,\n    line: int = 0,\n    column: int = 0,\n    off_symbol_length: int = 0,\n    context: ParserRuleContext = None,\n    syntax_error: bool = False,\n) -&gt; None:\n    \"\"\"Prints an error into the standard output.\n\n    Args:\n        error_msg: A string containing the error message\n        line: The line in which the error occured\n        column: The column in which the error occured\n        off_symbol_length: Length of the offending symbol\n        context: ANTLR Context object (lines and column will be used from this if not None)\n        syntax_error: A boolean indicating whether the error is a syntax error or not.\n    \"\"\"\n    if context:\n        line = context.start.line\n        column = context.start.column - 1\n        off_symbol_length = len(context.start.text)\n    if self.used_in_extension:\n        print(error_msg)\n        print(line)\n        print(column + 1)  # for ext: antlr starts at column 0, LSP at column 1\n        print(off_symbol_length)\n    else:\n        print(error_msg)\n        print(\"File \" + self.file_path + \", in line \" + str(line) + \":\" + str(column))\n\n    if syntax_error:\n        self.syntax_error_count = self.syntax_error_count + 1\n    else:\n        self.semantic_error_count = self.semantic_error_count + 1\n\n    self.total_error_count = self.total_error_count + 1\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker","title":"<code>semantic_error_checker</code>","text":"<p>Contains the SemanticErrorChecker class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker","title":"<code>SemanticErrorChecker(error_handler, process)</code>","text":"<p>Checks for static semantic errors in a given Process object.</p> <p>Each of the methods in this class checks for a specific semantic error. After calling the validate_process method the entire given process object and all the model objects it contains are tested for errors.</p> <p>Attributes:</p> Name Type Description <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors.</p> <code>process</code> <code>Process</code> <p>The Process object which has to be validated.</p> <code>tasks</code> <code>Dict[str, Task]</code> <p>A Dict that contains all Task objects of the given process object.</p> <code>structs</code> <code>Dict[str, Struct]</code> <p>A Dict that contains all Struct objects of the given process object.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors.</p> required <code>process</code> <code>Process</code> <p>The Process object which has to be validated.</p> required Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def __init__(self, error_handler: ErrorHandler, process: Process) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        error_handler: ErrorHandler instance for printing errors.\n        process: The Process object which has to be validated.\n    \"\"\"\n    self.error_handler: ErrorHandler = error_handler\n    self.process: Process = process\n    self.tasks: Dict[str, Task] = process.tasks\n    self.structs: Dict[str, Struct] = process.structs\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_array","title":"<code>check_array(instantiated_array, array_definition)</code>","text":"<p>Calls check methods to validate the instantiated array.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given array is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_array(self, instantiated_array: Array, array_definition: Array) -&gt; bool:\n    \"\"\"Calls check methods to validate the instantiated array.\n\n    Returns:\n        True if the given array is valid.\n    \"\"\"\n    error_msg = \"\"\n    element_type = array_definition.type_of_elements\n    for value in instantiated_array.values:\n        # type of Struct not checked yet\n        if isinstance(value, Struct):\n            if value.name == \"\":\n                value.name = array_definition.type_of_elements\n            if not self.check_instantiated_struct_attributes(value):\n                return False\n        if not helpers.check_type_of_value(value, element_type):\n            error_msg = (\n                f\"Array has elements that does not match \"\n                f\"with the defined type '{element_type}'\"\n            )\n            self.error_handler.print_error(error_msg, context=instantiated_array.context)\n            return False\n\n    if not self.instantiated_array_length_correct(instantiated_array, array_definition):\n        error_msg = \"Length of the defined array and the instantiated do not match\"\n        self.error_handler.print_error(error_msg, context=instantiated_array.context)\n        return False\n\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_attribute_access","title":"<code>check_attribute_access(variable_list, context, task)</code>","text":"<p>Checks if the attribute access via a variable list (for example x.y.z) is valid.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the attribute access is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_attribute_access(\n    self, variable_list: List[str], context: ParserRuleContext, task: Task\n) -&gt; bool:\n    \"\"\"Checks if the attribute access via a variable list (for example x.y.z) is valid.\n\n    Returns:\n        True if the attribute access is valid.\n    \"\"\"\n    variable = variable_list[0]\n    if variable in task.variables and task.variables[variable] in self.structs:\n        struct = self.structs[task.variables[variable]]\n        predecessor = struct\n        for i in range(1, len(variable_list)):\n            attribute = variable_list[i]\n            if not (attribute.startswith(\"[\") and attribute.endswith(\"]\")):\n                if attribute not in predecessor.attributes:\n                    error_msg = f\"Struct '{predecessor.name}' has no attribute '{attribute}'\"\n                    self.error_handler.print_error(error_msg, context=context)\n                    return False\n                if i &lt; len(variable_list) - 1:\n                    # check if this attribute is an array (next element is [])\n                    if not (\n                        variable_list[i + 1].startswith(\"[\")\n                        and variable_list[i + 1].endswith(\"]\")\n                    ):\n                        if predecessor.attributes[attribute] not in self.structs:\n                            error_msg = f\"Attribute '{attribute}' is not a Struct\"\n                            self.error_handler.print_error(error_msg, context=context)\n                            return False\n                        predecessor = self.structs[predecessor.attributes[attribute]]\n                    else:\n                        predecessor = self.structs[\n                            predecessor.attributes[attribute].type_of_elements\n                        ]\n    else:\n        error_msg = f\"Unknown variable '{variable}'.\"\n        self.error_handler.print_error(error_msg, context=context)\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_binary_operation","title":"<code>check_binary_operation(expression, context, task)</code>","text":"<p>Checks if a binary expression is a valid expression.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given binary expression is a valid expression.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_binary_operation(self, expression, context: ParserRuleContext, task: Task) -&gt; bool:\n    \"\"\"Checks if a binary expression is a valid expression.\n\n    Returns:\n        True if the given binary expression is a valid expression.\n    \"\"\"\n    left = expression[\"left\"]\n    right = expression[\"right\"]\n\n    if expression[\"binOp\"] in [\"&lt;\", \"&gt;\", \"&lt;=\", \"&gt;=\"]:\n        # Check if left and right side represent numbers or strings\n        if self.expression_is_number(left, task) and self.expression_is_number(right, task):\n            return True\n        if self.expression_is_string(left, task) and self.expression_is_string(right, task):\n            return True\n\n        msg = \"Types of Right and left side of the comparison dont match\"\n        self.error_handler.print_error(msg, context=context)\n        return False\n    if expression[\"binOp\"] in [\"*\", \"/\", \"+\", \"-\"]:\n        if self.expression_is_number(left, task) and self.expression_is_number(right, task):\n            return True\n        msg = \"Right and left side have to be numbers when using arithmetic operators\"\n        self.error_handler.print_error(msg, context=context)\n        return False\n    if left == \"(\" and right == \")\":\n        return self.check_expression(expression[\"binOp\"], context, task)\n\n    # expression is either 'and', 'or', '==' or '!='\n    return self.check_expression(left, context, task) and self.check_expression(\n        right, context, task\n    )\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_call_input_parameters","title":"<code>check_call_input_parameters(called_entity, task)</code>","text":"<p>Checks if the input parameters of a Service or Task Call are valid.</p> <p>Parameters:</p> Name Type Description Default <code>called_entity</code> <code>Union[Service, TaskCall]</code> <p>The evoked call (service or task call).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the input parameters of a Service or Task Call are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_call_input_parameters(\n    self, called_entity: Union[Service, TaskCall], task: Task\n) -&gt; bool:\n    \"\"\"Checks if the input parameters of a Service or Task Call are valid.\n\n    Args:\n        called_entity: The evoked call (service or task call).\n\n    Returns:\n        True if the input parameters of a Service or Task Call are valid.\n    \"\"\"\n    valid = True\n\n    for input_parameter in called_entity.input_parameters:\n        if isinstance(input_parameter, Struct):\n            if not self.check_instantiated_struct_attributes(input_parameter):\n                valid = False\n        elif isinstance(input_parameter, list):\n            if not self.check_attribute_access(\n                input_parameter, called_entity.context_dict[IN_KEY], task\n            ):\n                valid = False\n        elif not input_parameter in task.variables:\n            error_msg = (\n                f\"An unknown variable '{input_parameter}' is used as input of\"\n                f\" {type(called_entity).__name__} '{called_entity.name}'\"\n            )\n            self.error_handler.print_error(error_msg, context=called_entity.context)\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_call_output_parameters","title":"<code>check_call_output_parameters(called_entity)</code>","text":"<p>Checks if the output parameters of a Service or Task Call are valid.</p> <p>The output parameter of a call only consists of the visible variable name and the type of the variable. So all there is to check is the variable definition. This methods just calls the <code>check_if_variable_definition_is_valid</code> method for all output parameters.</p> <p>Parameters:</p> Name Type Description Default <code>called_entity</code> <code>Union[Service, TaskCall]</code> <p>The evoked call (service or task call).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the output parameters of a Service or Task Call are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_call_output_parameters(self, called_entity: Union[Service, TaskCall]) -&gt; bool:\n    \"\"\"Checks if the output parameters of a Service or Task Call are valid.\n\n    The output parameter of a call only consists of the visible variable name and\n    the type of the variable. So all there is to check is the variable definition.\n    This methods just calls the `check_if_variable_definition_is_valid` method for all\n    output parameters.\n\n    Args:\n        called_entity: The evoked call (service or task call).\n\n    Returns:\n        True if the output parameters of a Service or Task Call are valid.\n    \"\"\"\n    valid = True\n    for identifier, variable_type in called_entity.output_parameters.items():\n        if not self.check_if_variable_definition_is_valid(\n            identifier, variable_type, called_entity.context\n        ):\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_call_parameters","title":"<code>check_call_parameters(called_entity, task)</code>","text":"<p>Checks if the parameters of a Service or Task call are valid (input and output).</p> <p>Parameters:</p> Name Type Description Default <code>called_entity</code> <code>Union[Service, TaskCall]</code> <p>The evoked call (service or task call).</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the parameters of a Service or Task call are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_call_parameters(self, called_entity: Union[Service, TaskCall], task: Task) -&gt; bool:\n    \"\"\"Checks if the parameters of a Service or Task call are valid (input and output).\n\n    Args:\n        called_entity: The evoked call (service or task call).\n\n    Returns:\n        True if the parameters of a Service or Task call are valid.\n    \"\"\"\n    valid = True\n    if called_entity.input_parameters:\n        valid = self.check_call_input_parameters(called_entity, task)\n    if called_entity.output_parameters:\n        valid = valid &amp; self.check_call_output_parameters(called_entity)\n\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_conditional_statement","title":"<code>check_conditional_statement(condition, task)</code>","text":"<p>Calls check methods for the conditional statement.</p> <p>Calls check_statement for the Passed and Failed statements and checks if the boolean expression is valid.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the conditional statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_conditional_statement(self, condition: Condition, task: Task) -&gt; bool:\n    \"\"\"Calls check methods for the conditional statement.\n\n    Calls check_statement for the Passed and Failed statements and checks if the\n    boolean expression is valid.\n\n    Returns:\n        True if the conditional statement is valid.\n    \"\"\"\n    valid = True\n    for statement in condition.passed_stmts:\n        if not self.check_statement(statement, task):\n            valid = False\n\n    for statement in condition.failed_stmts:\n        if not self.check_statement(statement, task):\n            valid = False\n\n    if not self.check_expression(condition.expression, condition.context, task):\n        valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_counting_loop","title":"<code>check_counting_loop(counting_loop, task)</code>","text":"<p>Calls check methods for the Counting Loop statement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the Counting Loop statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_counting_loop(self, counting_loop: CountingLoop, task: Task) -&gt; bool:\n    \"\"\"Calls check methods for the Counting Loop statement.\n\n    Returns:\n        True if the Counting Loop statement is valid.\n    \"\"\"\n    valid = True\n    for statement in counting_loop.statements:\n        if not self.check_statement(statement, task):\n            valid = False\n\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_expression","title":"<code>check_expression(expression, context, task)</code>","text":"<p>Executes checks to test given expression.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given expression is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_expression(\n    self, expression: Union[str, dict], context: ParserRuleContext, task: Task\n) -&gt; bool:\n    \"\"\"Executes checks to test given expression.\n\n    Returns:\n        True if the given expression is valid.\n    \"\"\"\n    if isinstance(expression, (list, str)):\n        if not self.check_single_expression(expression, context, task):\n            return False\n    elif isinstance(expression, dict):\n        if len(expression) == 2:\n            if not self.check_unary_operation(expression, context, task):\n                return False\n        else:\n            if not self.check_binary_operation(expression, context, task):\n                return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_for_missing_attribute_in_struct","title":"<code>check_for_missing_attribute_in_struct(struct, struct_definition)</code>","text":"<p>Checks if an instantiated Struct is missing an attribute from the Struct definition.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if no attributes are missing.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_for_missing_attribute_in_struct(\n    self, struct: Struct, struct_definition: Struct\n) -&gt; bool:\n    \"\"\"Checks if an instantiated Struct is missing an attribute from the Struct definition.\n\n    Returns:\n        True if no attributes are missing.\n    \"\"\"\n    for attribute in struct_definition.attributes:\n        if attribute not in struct.attributes:\n            error_msg = (\n                f\"Attribute '{attribute}' is not defined in \"\n                f\"the instantiated struct '{struct.name}'\"\n            )\n            self.error_handler.print_error(error_msg, context=struct.context)\n            return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_for_unknown_attribute_in_struct","title":"<code>check_for_unknown_attribute_in_struct(struct_instance, identifier, struct_definition)</code>","text":"<p>Checks if the given identifier in the instantiated struct exists in the struct definition.</p> <p>Parameters:</p> Name Type Description Default <code>struct_instance</code> <code>Struct</code> <p>The instantiated struct that is checked.</p> required <code>identifier</code> <code>str</code> <p>The identifier in the struct instance which should be checked.</p> required <code>struct_definition</code> <code>Struct</code> <p>The corresponding struct definition.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given identifier exists in the struct definition.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_for_unknown_attribute_in_struct(\n    self, struct_instance: Struct, identifier: str, struct_definition: Struct\n) -&gt; bool:\n    \"\"\"Checks if the given identifier in the instantiated struct\n    exists in the struct definition.\n\n    Args:\n        struct_instance: The instantiated struct that is checked.\n        identifier: The identifier in the struct instance which should be checked.\n        struct_definition: The corresponding struct definition.\n\n    Returns:\n        True if the given identifier exists in the struct definition.\n    \"\"\"\n    if identifier not in struct_definition.attributes:\n        error_msg = (\n            f\"Unknown attribute '{identifier}' in instantiated \"\n            f\"struct '{struct_definition.name}'\"\n        )\n        self.error_handler.print_error(error_msg, context=struct_instance.context)\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_for_unknown_datatypes_in_struct_definition","title":"<code>check_for_unknown_datatypes_in_struct_definition(struct)</code>","text":"<p>Checks for each attribute definition in the struct if the defined type exists.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all datatypes in the given struct are known.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_for_unknown_datatypes_in_struct_definition(self, struct: Struct) -&gt; bool:\n    \"\"\"Checks for each attribute definition in the struct if the defined type exists.\n\n    Returns:\n        True if all datatypes in the given struct are known.\n    \"\"\"\n    datatypes_known = True\n    for identifier, attribute_type in struct.attributes.items():\n        if not self.check_if_variable_definition_is_valid(\n            identifier, attribute_type, struct.context\n        ):\n            datatypes_known = False\n    return datatypes_known\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_for_wrong_attribute_type_in_struct","title":"<code>check_for_wrong_attribute_type_in_struct(struct_instance, identifier, struct_definition)</code>","text":"<p>Calls check methods for the attribute assignments in an instantiated Struct.</p> <p>This methods assumes that the given identifier is not unknown. Args:     struct_instance: The instantiated struct that is checked.     identifier: The identifier in the struct instance which should be checked.     struct_definition: The corresponding struct definition.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given identifier in the struct instance matches with the struct definition.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_for_wrong_attribute_type_in_struct(\n    self, struct_instance: Struct, identifier: str, struct_definition: Struct\n) -&gt; bool:\n    \"\"\"Calls check methods for the attribute assignments in an instantiated Struct.\n\n    This methods assumes that the given identifier is not unknown.\n    Args:\n        struct_instance: The instantiated struct that is checked.\n        identifier: The identifier in the struct instance which should be checked.\n        struct_definition: The corresponding struct definition.\n\n    Returns:\n        True if the given identifier in the struct instance matches with the struct definition.\n    \"\"\"\n    correct_attribute_type = struct_definition.attributes[identifier]\n    attribute = struct_instance.attributes[identifier]\n\n    if isinstance(correct_attribute_type, str):\n        if correct_attribute_type in self.structs:\n\n            # check for structs which has structs as attribute\n            if isinstance(attribute, Struct):\n                attribute.name = correct_attribute_type\n                struct_def = self.structs[correct_attribute_type]\n                struct_correct = True\n                for identifier in attribute.attributes:\n                    if not self.check_for_wrong_attribute_type_in_struct(\n                        attribute, identifier, struct_def\n                    ):\n                        struct_correct = False\n                return struct_correct\n            error_msg = (\n                f\"Attribute '{identifier}' has the wrong type in the \"\n                f\"instantiated Struct '{struct_instance.name}', expected \"\n                f\"Struct '{correct_attribute_type}'\"\n            )\n            self.error_handler.print_error(error_msg, context=struct_instance.context)\n            return False\n        if not helpers.check_type_of_value(attribute, correct_attribute_type):\n            error_msg = (\n                f\"Attribute '{identifier}' has the wrong type in the instantiated\"\n                f\" Struct '{struct_instance.name}', expected '{correct_attribute_type}'\"\n            )\n            self.error_handler.print_error(error_msg, context=struct_instance.context)\n            return False\n\n    elif isinstance(correct_attribute_type, Array):\n        if not isinstance(attribute, Array) or not self.check_array(\n            attribute, correct_attribute_type\n        ):\n            error_msg = (\n                f\"Attribute '{identifier}' has the wrong type in the instantiated\"\n                f\" Struct '{struct_instance.name}', expected 'Array'\"\n            )\n            self.error_handler.print_error(error_msg, context=struct_instance.context)\n            return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_input_parameter_matches","title":"<code>check_if_input_parameter_matches(input_parameter, identifier, defined_type, task_call, called_task, task_context)</code>","text":"<p>Checks if the input parameters of a Taskcall matches with the called Task.</p> <p>This method assumes that the validity of the input parameter itself was already checked.</p> <p>Parameters:</p> Name Type Description Default <code>input_parameter</code> <code>Union[str, List[str], Struct]</code> <p>The input parameter of the TaskCall.</p> required <code>identifier</code> <code>str</code> <p>Parameter name of the input in the called task (only for error message).</p> required <code>defined_type</code> <code>Union[str, Array]</code> <p>Type of the input in the called task.</p> required <code>task_call</code> <code>TaskCall</code> <p>The TaskCall the input parameter is from.</p> required <code>called_task</code> <code>Task</code> <p>The Task the TaskCall is refering to (the called task).</p> required <code>task_context</code> <code>Task</code> <p>The Task in which the TaskCall was evoked.</p> required <p>Returns:     True if the input parameters of a Taskcall matches with the called Task.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_input_parameter_matches(\n    self,\n    input_parameter: Union[str, List[str], Struct],\n    identifier: str,\n    defined_type: Union[str, Array],\n    task_call: TaskCall,\n    called_task: Task,\n    task_context: Task,\n) -&gt; bool:\n    \"\"\"Checks if the input parameters of a Taskcall matches with the called Task.\n\n    This method assumes that the validity of the input parameter itself was already checked.\n\n    Args:\n        input_parameter: The input parameter of the TaskCall.\n        identifier: Parameter name of the input in the called task (only for error message).\n        defined_type: Type of the input in the called task.\n        task_call: The TaskCall the input parameter is from.\n        called_task: The Task the TaskCall is refering to (the called task).\n        task_context: The Task in which the TaskCall was evoked.\n    Returns:\n        True if the input parameters of a Taskcall matches with the called Task.\n    \"\"\"\n    if isinstance(input_parameter, str):\n        if input_parameter in task_context.variables:\n            type_of_variable = task_context.variables[input_parameter]\n\n            # str() because of possible Arrays as\n            # types (we can compare types by converting Array object to string)\n            if str(type_of_variable) != str(defined_type):\n                error_msg = (\n                    f\"Type of TaskCall parameter '{input_parameter}' does not match \"\n                    f\"with type '{defined_type}' of Input Parameter '{identifier}' in\"\n                    f\" Task '{called_task.name}'\"\n                )\n                self.error_handler.print_error(\n                    error_msg,\n                    context=task_call.context,\n                    off_symbol_length=len(task_call.name),\n                )\n                return False\n        else:\n            error_msg = (\n                f\"Type of TaskCall parameter '{input_parameter}' does not match with \"\n                f\"type '{defined_type}' of Input Parameter '{identifier}' in Task \"\n                f\"'{called_task.name}'\"\n            )\n            self.error_handler.print_error(\n                error_msg,\n                context=task_call.context,\n                off_symbol_length=len(task_call.name),\n            )\n            return False\n    elif isinstance(input_parameter, list):\n        # At this point it is known that the variable chain is valid, so dont check again\n        current_struct = self.structs[task_context.variables[input_parameter[0]]]\n        i = 1\n        while i &lt; len(input_parameter) - 1:\n            element = current_struct.attributes[input_parameter[i]]\n            if isinstance(element, Array):\n                i = i + 1\n                current_struct = self.structs[element.type_of_elements]\n            else:\n                current_struct = self.structs[element]\n            i = i + 1\n\n        index = len(input_parameter) - 1\n        if input_parameter[index].startswith(\"[\"):\n            given_type = current_struct.name\n        else:\n            given_type = current_struct.attributes[input_parameter[index]]\n        if given_type != defined_type:\n            error_msg = (\n                \"Type of TaskCall parameter \"\n                f\"'{input_parameter[len(input_parameter)-1]}' does not match with \"\n                f\"type '{defined_type}' of Input Parameter '{identifier}' \"\n                f\"in Task '{called_task.name}'\"\n            )\n            self.error_handler.print_error(\n                error_msg,\n                context=task_call.context,\n                off_symbol_length=len(task_call.name),\n            )\n            return False\n    elif isinstance(input_parameter, Struct):\n        if input_parameter.name != defined_type:\n            error_msg = (\n                f\"Type of TaskCall parameter '{input_parameter.name}' does not match \"\n                f\"with type '{defined_type}' of Input Parameter '{identifier}' in \"\n                f\"Task '{called_task.name}'\"\n            )\n            self.error_handler.print_error(\n                error_msg,\n                context=task_call.context,\n                off_symbol_length=len(task_call.name),\n            )\n            return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_struct_exists","title":"<code>check_if_struct_exists(struct)</code>","text":"<p>Checks if the given Struct instance refers to a existing Struct definition.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given Struct instance refers to a existing Struct definition.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_struct_exists(self, struct: Struct) -&gt; bool:\n    \"\"\"Checks if the given Struct instance refers to a existing Struct definition.\n\n    Returns:\n        True if the given Struct instance refers to a existing Struct definition.\n    \"\"\"\n    if struct.name not in self.structs:\n        error_msg = f\"Unknown Struct '{struct.name}'\"\n        self.error_handler.print_error(error_msg, context=struct.context)\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_task_call_matches_with_called_task","title":"<code>check_if_task_call_matches_with_called_task(task_call, task)</code>","text":"<p>Checks if the parameters of the Taskcall matches with the parameters of the Task.</p> <p>This method assumes that the validity of the input parameter itself was already checked.</p> Multiple Checks are done <p>(1) Checks if length of parameters of Taskcall and Task match. (2) Checks if types of input parameters match. (3) Checks if types of output parameters match.</p> <p>Parameters:</p> Name Type Description Default <code>task_call</code> <code>TaskCall</code> <p>The task call to be checked.</p> required <code>task_context</code> <p>The task in which the task call is defined.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the parameters matches.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_task_call_matches_with_called_task(self, task_call: TaskCall, task: Task) -&gt; bool:\n    \"\"\"Checks if the parameters of the Taskcall matches with the parameters of the Task.\n\n    This method assumes that the validity of the input parameter itself was already checked.\n\n    Multiple Checks are done:\n        (1) Checks if length of parameters of Taskcall and Task match.\n        (2) Checks if types of input parameters match.\n        (3) Checks if types of output parameters match.\n\n    Args:\n        task_call: The task call to be checked.\n        task_context: The task in which the task call is defined.\n\n    Returns:\n        True if the parameters matches.\n    \"\"\"\n    called_task = self.tasks[task_call.name]\n    if not self.check_if_task_call_parameter_length_match(task_call):\n        return False\n\n    valid = True\n    for i, input_parameter in enumerate(task_call.input_parameters):\n        identifier = list(called_task.input_parameters.items())[i][0]\n        defined_type = list(called_task.input_parameters.items())[i][1]\n        if not self.check_if_input_parameter_matches(\n            input_parameter, identifier, defined_type, task_call, called_task, task\n        ):\n            valid = False\n\n    for i, (identifier, data_type) in enumerate(task_call.output_parameters.items()):\n        variable_in_called_task = called_task.output_parameters[i]\n        if variable_in_called_task in called_task.variables:\n            type_of_variable = called_task.variables[variable_in_called_task]\n\n            if str(type_of_variable) != str(data_type):\n                error_msg = (\n                    f\"Type of TaskCall output parameter at position {str((i+1))} does not \"\n                    f\"match with type '{type_of_variable}' of output parameter \"\n                    f\"'{variable_in_called_task}' in Task '{called_task.name}'\"\n                )\n                self.error_handler.print_error(\n                    error_msg,\n                    context=task_call.context,\n                    off_symbol_length=len(task_call.name),\n                )\n                valid = False\n\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_task_call_parameter_length_match","title":"<code>check_if_task_call_parameter_length_match(task_call)</code>","text":"<p>Checks if the length of the Task call parameters match with the called Task.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the parameter lengths matches.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_task_call_parameter_length_match(self, task_call: TaskCall) -&gt; bool:\n    \"\"\"Checks if the length of the Task call parameters match with the called Task.\n\n    Returns:\n        True if the parameter lengths matches.\n    \"\"\"\n    called_task = self.tasks[task_call.name]\n    if len(called_task.input_parameters) != len(task_call.input_parameters):\n        error_msg = \"Inputparameter length of Task Call and called Task dont match\"\n        self.error_handler.print_error(error_msg, context=task_call.context)\n        return False\n    if len(called_task.output_parameters) != len(task_call.output_parameters):\n        error_msg = \"Outputparameter length of Task Call and called Task dont match\"\n        self.error_handler.print_error(error_msg, context=task_call.context)\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_task_in_taskcall_exists","title":"<code>check_if_task_in_taskcall_exists(task_name, context)</code>","text":"<p>Checks if the Task name in the Taskcall belongs to a Task.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given name belongs to a Task.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_task_in_taskcall_exists(self, task_name: str, context: ParserRuleContext) -&gt; bool:\n    \"\"\"Checks if the Task name in the Taskcall belongs to a Task.\n\n    Returns:\n        True if the given name belongs to a Task.\n    \"\"\"\n    if task_name not in self.tasks:\n        error_msg = \"Unknown Task '\" + task_name + \"'\"\n        self.error_handler.print_error(error_msg, context=context)\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_if_variable_definition_is_valid","title":"<code>check_if_variable_definition_is_valid(identifier, variable_type, context)</code>","text":"<p>Checks if the variable has the correct type.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if variable definition is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_if_variable_definition_is_valid(\n    self, identifier: str, variable_type: Union[str, Array], context\n) -&gt; bool:\n    \"\"\"Checks if the variable has the correct type.\n\n    Returns:\n        True if variable definition is valid.\n    \"\"\"\n    valid = True\n    if isinstance(variable_type, str):\n        if not self.variable_type_exists(variable_type):\n            valid = False\n    elif isinstance(variable_type, Array):\n        element_type = variable_type.type_of_elements\n        if not self.variable_type_exists(element_type):\n            valid = False\n\n    if not valid:\n        error_msg = (\n            f\"Unknown data type '{variable_type}' for task \" f\"input variable '{identifier}'\"\n        )\n        self.error_handler.print_error(error_msg, context=context)\n        return False\n\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_instantiated_struct_attributes","title":"<code>check_instantiated_struct_attributes(struct_instance)</code>","text":"<p>Calls multiple check methods to validate an instantiated Struct.</p> Multiple Checks are done <p>(1) Check if the name of the struct instance exists in the struct definitions. (2) Check if attributes from the struct definition are missing. (3) Check if there are attributes in the instance that do not exist in the definition. (4) Check if attributes in the instance do not match with attributes in the definition.</p> <p>Parameters:</p> Name Type Description Default <code>struct_instance</code> <code>Struct</code> <p>The instantiated struct that is checked.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the instantiated Struct is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_instantiated_struct_attributes(self, struct_instance: Struct) -&gt; bool:\n    \"\"\"Calls multiple check methods to validate an instantiated Struct.\n\n    Multiple Checks are done:\n        (1) Check if the name of the struct instance exists in the struct definitions.\n        (2) Check if attributes from the struct definition are missing.\n        (3) Check if there are attributes in the instance that do not exist in the definition.\n        (4) Check if attributes in the instance do not match with attributes in the definition.\n\n    Args:\n        struct_instance: The instantiated struct that is checked.\n\n    Returns:\n        True if the instantiated Struct is valid.\n    \"\"\"\n    valid = True\n    if self.check_if_struct_exists(struct_instance):\n        struct_definition = self.structs[struct_instance.name]\n\n        if not self.check_for_missing_attribute_in_struct(struct_instance, struct_definition):\n            valid = False\n\n        for identifier in struct_instance.attributes:\n            if not (\n                self.check_for_unknown_attribute_in_struct(\n                    struct_instance, identifier, struct_definition\n                )\n                and self.check_for_wrong_attribute_type_in_struct(\n                    struct_instance, identifier, struct_definition\n                )\n            ):\n                valid = False\n    else:\n        valid = False\n\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_parallel","title":"<code>check_parallel(parallel, task)</code>","text":"<p>Calls check methods for the Parallel statement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given Parallel statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_parallel(self, parallel: Parallel, task: Task) -&gt; bool:\n    \"\"\"Calls check methods for the Parallel statement.\n\n    Returns:\n        True if the given Parallel statement is valid.\n    \"\"\"\n\n    valid = True\n    for task_call in parallel.task_calls:\n        if not self.check_task_call(task_call, task):\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_service","title":"<code>check_service(service, task)</code>","text":"<p>Calls check methods for the Service or Service Call statement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given Service statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_service(self, service: Service, task: Task) -&gt; bool:\n    \"\"\"Calls check methods for the Service or Service Call statement.\n\n    Returns:\n        True if the given Service statement is valid.\n    \"\"\"\n    if not self.check_call_parameters(service, task):\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_single_expression","title":"<code>check_single_expression(expression, context, task)</code>","text":"<p>Checks if a single expression is a valid expression.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given single expression is a valid expression.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_single_expression(\n    self, expression: Union[str, list], context: ParserRuleContext, task: Task\n) -&gt; bool:\n    \"\"\"Checks if a single expression is a valid expression.\n\n    Returns:\n        True if the given single expression is a valid expression.\n    \"\"\"\n    if isinstance(expression, (str, int, float, bool)):\n        return True\n    if isinstance(expression, list):\n        if not self.check_attribute_access(expression, context, task):\n            return False\n\n        variable_type = helpers.get_type_of_variable_list(expression, task, self.structs)\n        if not (isinstance(variable_type, str) and variable_type in [\"number\", \"boolean\"]):\n            msg = \"The given attribute can not be resolved to a boolean expression\"\n            self.error_handler.print_error(\n                msg, context=context, off_symbol_length=len(expression)\n            )\n            return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_statement","title":"<code>check_statement(statement, task)</code>","text":"<p>Calls check methods depending on the type of the statement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_statement(\n    self,\n    statement: Union[Service, TaskCall, WhileLoop, CountingLoop, Condition],\n    task: Task,\n) -&gt; bool:\n    \"\"\"Calls check methods depending on the type of the statement.\n\n    Returns:\n        True if the given statement is valid.\n    \"\"\"\n    if isinstance(statement, Service):\n        return self.check_service(statement, task)\n    if isinstance(statement, TaskCall):\n        return self.check_task_call(statement, task)\n    if isinstance(statement, Parallel):\n        return self.check_parallel(statement, task)\n    if isinstance(statement, WhileLoop):\n        return self.check_while_loop(statement, task)\n    if isinstance(statement, CountingLoop):\n        return self.check_counting_loop(statement, task)\n    return self.check_conditional_statement(statement, task)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_statements","title":"<code>check_statements(task)</code>","text":"<p>Executes semantic checks for all statements in a Task.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all Statements are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_statements(self, task: Task) -&gt; bool:\n    \"\"\"Executes semantic checks for all statements in a Task.\n\n    Returns:\n        True if all Statements are valid.\n    \"\"\"\n    valid = True\n    for statement in task.statements:\n        if not self.check_statement(statement, task):\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_structs","title":"<code>check_structs()</code>","text":"<p>Executes semantic checks for each Struct.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all Struct definitions are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_structs(self) -&gt; bool:\n    \"\"\"Executes semantic checks for each Struct.\n\n    Returns:\n        True if all Struct definitions are valid.\n    \"\"\"\n    valid = True\n    for struct in self.structs.values():\n        if not self.check_for_unknown_datatypes_in_struct_definition(struct):\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_task_call","title":"<code>check_task_call(task_call, task_context)</code>","text":"<p>Calls check methods for the TaskCall statement.</p> <p>Parameters:</p> Name Type Description Default <code>task_call</code> <code>TaskCall</code> <p>The task call to be checked.</p> required <code>task_context</code> <code>Task</code> <p>The task in which the task call is defined.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the given TaskCall statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_task_call(self, task_call: TaskCall, task_context: Task) -&gt; bool:\n    \"\"\"Calls check methods for the TaskCall statement.\n\n    Args:\n        task_call: The task call to be checked.\n        task_context: The task in which the task call is defined.\n\n    Returns:\n        True if the given TaskCall statement is valid.\n    \"\"\"\n    if self.check_if_task_in_taskcall_exists(task_call.name, task_call.context):\n        if not (\n            self.check_call_parameters(task_call, task_context)\n            and self.check_if_task_call_matches_with_called_task(task_call, task_context)\n        ):\n            return False\n    else:\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_task_input_parameters","title":"<code>check_task_input_parameters(task)</code>","text":"<p>Checks if the input parameters are valid.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the input parameters of the given Task are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_task_input_parameters(self, task: Task) -&gt; bool:\n    \"\"\"Checks if the input parameters are valid.\n\n    Returns:\n        True if the input parameters of the given Task are valid.\n    \"\"\"\n    valid = True\n    # input_parameters: &lt;identifier&gt;: &lt;variable_type&gt;\n    for identifier, variable_type in task.input_parameters.items():\n        if not self.check_if_variable_definition_is_valid(\n            identifier, variable_type, context=task.context_dict[IN_KEY]\n        ):\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_task_output_parameters","title":"<code>check_task_output_parameters(task)</code>","text":"<p>Checks if the output parameters are valid.</p> <p>Checks if the variable names used as parameters are variables defined in the Task.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the output parameters of the given Task are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_task_output_parameters(self, task: Task) -&gt; bool:\n    \"\"\"Checks if the output parameters are valid.\n\n    Checks if the variable names used as parameters are variables\n    defined in the Task.\n\n    Returns:\n        True if the output parameters of the given Task are valid.\n    \"\"\"\n    valid = True\n    for output_param in task.output_parameters:\n        if not output_param in task.variables:\n            error_msg = (\n                f\"An unknown variable '{output_param}' is used \"\n                f\"in the Task Output of Task '{task.name}'\"\n            )\n            self.error_handler.print_error(error_msg, context=task.context_dict[OUT_KEY])\n            valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_tasks","title":"<code>check_tasks()</code>","text":"<p>Executes semantic checks for each Task.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if all Task definitions are valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_tasks(self) -&gt; bool:\n    \"\"\"Executes semantic checks for each Task.\n\n    Returns:\n        True if all Task definitions are valid.\n    \"\"\"\n    valid = True\n\n    start_task_found = False\n    for task in self.tasks.values():\n        if task.name == START_TASK:\n            start_task_found = True\n\n        # use &amp; so all methods will be executed even if a method returns False\n        if not (\n            self.check_statements(task)\n            &amp; self.check_task_input_parameters(task)\n            &amp; self.check_task_output_parameters(task)\n        ):\n            valid = False\n\n    if not start_task_found:\n        error_msg = \"The file contains no 'productionTask' (Starting Point)\"\n        self.error_handler.print_error(error_msg, line=1, column=0, off_symbol_length=5)\n        return False\n\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_unary_operation","title":"<code>check_unary_operation(expression, context, task)</code>","text":"<p>Checks if a unary expression is a valid expression.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given unary expression is a valid expression.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_unary_operation(self, expression, context: ParserRuleContext, task: Task) -&gt; bool:\n    \"\"\"Checks if a unary expression is a valid expression.\n\n    Returns:\n        True if the given unary expression is a valid expression.\n    \"\"\"\n    return self.check_expression(expression[\"value\"], context, task)\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.check_while_loop","title":"<code>check_while_loop(while_loop, task)</code>","text":"<p>Calls check methods for the While Loop statement.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the While Loop statement is valid.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def check_while_loop(self, while_loop: WhileLoop, task: Task) -&gt; bool:\n    \"\"\"Calls check methods for the While Loop statement.\n\n    Returns:\n        True if the While Loop statement is valid.\n    \"\"\"\n    valid = True\n    for statement in while_loop.statements:\n        if not self.check_statement(statement, task):\n            valid = False\n\n    if not self.check_expression(while_loop.expression, while_loop.context, task):\n        valid = False\n    return valid\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.expression_is_number","title":"<code>expression_is_number(expression, task)</code>","text":"<p>Checks if the given expression is a number (int or float).</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given expression is a number.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def expression_is_number(self, expression, task: Task) -&gt; bool:\n    \"\"\"Checks if the given expression is a number (int or float).\n\n    Returns:\n        True if the given expression is a number.\n    \"\"\"\n    if isinstance(expression, (int, float, bool)):\n        return True\n    if isinstance(expression, list):\n        given_type = helpers.get_type_of_variable_list(expression, task, self.structs)\n        return isinstance(given_type, str) and given_type == \"number\"\n    if isinstance(expression, dict):\n        if expression[\"left\"] == \"(\" and expression[\"right\"] == \")\":\n            return self.expression_is_number(expression[\"binOp\"], task)\n        else:\n            return self.expression_is_number(\n                expression[\"left\"], task\n            ) and self.expression_is_number(expression[\"right\"], task)\n\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.expression_is_string","title":"<code>expression_is_string(expression, task)</code>","text":"<p>Checks if the given expression is a PFDL string.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the given expression is a PFDL string.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def expression_is_string(self, expression, task: Task) -&gt; bool:\n    \"\"\"Checks if the given expression is a PFDL string.\n\n    Returns:\n        True if the given expression is a PFDL string.\n    \"\"\"\n    if isinstance(expression, str):\n        return True\n    if isinstance(expression, list):\n        given_type = helpers.get_type_of_variable_list(expression, task, self.structs)\n        return isinstance(given_type, str) and given_type == \"string\"\n    return False\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.instantiated_array_length_correct","title":"<code>instantiated_array_length_correct(instantiated_array, array_definition)</code>","text":"<p>Checks if the length of the instantiated array matches with the array definition.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if both lengths are equal.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def instantiated_array_length_correct(\n    self, instantiated_array: Array, array_definition: Array\n) -&gt; bool:\n    \"\"\"Checks if the length of the instantiated array matches with the array definition.\n\n    Returns:\n        True if both lengths are equal.\n    \"\"\"\n    if array_definition.length != -1:\n        return instantiated_array.length == array_definition.length\n    # dynamic length\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.validate_process","title":"<code>validate_process()</code>","text":"<p>Starts static semantic checks.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True, if the process has no errors, otherwise False.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def validate_process(self) -&gt; bool:\n    \"\"\"Starts static semantic checks.\n\n    Returns:\n        True, if the process has no errors, otherwise False.\n    \"\"\"\n    # use &amp; so all methods will be executed even if a method returns False\n    return self.check_structs() &amp; self.check_tasks()\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.semantic_error_checker.SemanticErrorChecker.variable_type_exists","title":"<code>variable_type_exists(variable_type)</code>","text":"<p>Checks if the given variable type exists in the PFDL file.</p> <p>A variable type can be a primitive (number, string or boolean) or an identifier of a defined Struct.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the variable type exists within the PFDL file.</p> Source code in <code>pfdl_scheduler/validation/semantic_error_checker.py</code> <pre><code>def variable_type_exists(self, variable_type: str) -&gt; bool:\n    \"\"\"Checks if the given variable type exists in the PFDL file.\n\n    A variable type can be a primitive (number, string or boolean) or\n    an identifier of a defined Struct.\n\n    Returns:\n        True if the variable type exists within the PFDL file.\n    \"\"\"\n    if variable_type[0].isupper():\n        if variable_type not in self.structs:\n            return False\n    elif variable_type not in [\"number\", \"string\", \"boolean\"]:\n        return False\n    return True\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.syntax_error_listener","title":"<code>syntax_error_listener</code>","text":"<p>Contains SyntaxErrorListener class.</p>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.syntax_error_listener.SyntaxErrorListener","title":"<code>SyntaxErrorListener(token_stream, error_handler)</code>","text":"<p>             Bases: <code>ErrorListener</code></p> <p>Custom ErrorListener for the PFDL.</p> <p>Overrides Antlr ErrorListener class so we can use our ErrorHandler class for syntax errors.</p> <p>Attributes:</p> Name Type Description <code>token_stream</code> <code>CommonTokenStream</code> <p>ANTLR token stream.</p> <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>token_stream</code> <code>CommonTokenStream</code> <p>ANTLR token stream.</p> required <code>error_handler</code> <code>ErrorHandler</code> <p>ErrorHandler instance for printing errors.</p> required Source code in <code>pfdl_scheduler/validation/syntax_error_listener.py</code> <pre><code>def __init__(self, token_stream: CommonTokenStream, error_handler: ErrorHandler) -&gt; None:\n    \"\"\"Initialize the object.\n\n    Args:\n        token_stream: ANTLR token stream.\n        error_handler: ErrorHandler instance for printing errors.\n    \"\"\"\n    super()\n    self.token_stream: CommonTokenStream = token_stream\n    self.error_handler: ErrorHandler = error_handler\n</code></pre>"},{"location":"scheduler/developer_reference/#pfdl_scheduler.validation.syntax_error_listener.SyntaxErrorListener.syntaxError","title":"<code>syntaxError(recognizer, offendingSymbol, line, column, msg, e)</code>","text":"<p>Overwrites the ANTLR ErrorListener method to use the error handler.</p> Source code in <code>pfdl_scheduler/validation/syntax_error_listener.py</code> <pre><code>def syntaxError(\n    self,\n    recognizer: Recognizer,\n    offendingSymbol: Any,\n    line: int,\n    column: int,\n    msg: str,\n    e: RecognitionException,\n) -&gt; None:\n    \"\"\"Overwrites the ANTLR ErrorListener method to use the error handler.\"\"\"\n    self.error_handler.print_error(msg, line=line, column=column, syntax_error=True)\n</code></pre>"},{"location":"scheduler/model_classes/","title":"Model classes","text":""},{"location":"scheduler/model_classes/#model-classes","title":"Model classes","text":"<p>This page provides an overview over the model classes which are extracted from the parsed PFDL file. For an overview visit the architecture section.</p>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.array.Array","title":"<code>pfdl_scheduler.model.array.Array(type_of_elements='', values=None, context=None)</code>","text":"<p>Represents an Array in the PFDL.</p> <p>Used as as an array definition or a returned array with elements in it.</p> <p>Attributes:</p> Name Type Description <code>type_of_elements</code> <code>str</code> <p>A string representing the type of the elements inside the array.</p> <code>values</code> <code>List[Any]</code> <p>A list of elements of the Array (empty if it is a array definition).</p> <code>length</code> <code>int</code> <p>An integer for the length of the Array. If it is not defined it gets the value -1.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>type_of_elements</code> <code>str</code> <p>A string representing the type of the elements inside the array.</p> <code>''</code> <code>values</code> <code>List[Any]</code> <p>A list of elements of the Array (empty if it is a array definition).</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.array.Array.append_value","title":"<code>append_value(value)</code>","text":"<p>Adds an element to the array and increase the length.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value that should be added to the array.</p> required"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.array.Array.length_defined","title":"<code>length_defined()</code>","text":"<p>Returns whether the lenght of the array is defined.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the length of the array is defined.</p>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.condition.Condition","title":"<code>pfdl_scheduler.model.condition.Condition(expression=None, passed_stmts=None, failed_stmts=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a conditional statement in the PFDL.</p> <p>A Condition consists of a boolean expression which has to be satisfied in order to execute the statements in the Passed block. Otherwise the statements in the Failed block will be executed.</p> <p>Attributes:</p> Name Type Description <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict (see Visitor for the dict structure).</p> <code>passed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is satisfied.</p> <code>failed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is not satisfied.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict (see Visitor for the dict structure).</p> <code>None</code> <code>passed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is satisfied.</p> <code>None</code> <code>failed_stmts</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements which are executed when the expression is not satisfied.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.counting_loop.CountingLoop","title":"<code>pfdl_scheduler.model.counting_loop.CountingLoop(statements=None, counting_variable='', limit='', parallel=False, context=None)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Loop</code></p> <p>Represents a Counting Loop in the PFDL.</p> <p>Counting loops count a variable from an initial value to a given upper limit. If the parallel keyword was used, this loop executes the statements in the loop body in parallel as many times as the loop would iterate.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <p>List of statements inside the loop body.</p> <code>context</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <p>Maps other attributes with ANTLR context objects.</p> <code>counting_variable</code> <code>str</code> <p>Name of the variable which is counted in the loop.</p> <code>limit</code> <code>str</code> <p>Integer for the upper limit.</p> <code>parallel</code> <code>bool</code> <p>A boolean indicating if the loop is a parallel loop or not.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>counting_variable</code> <code>str</code> <p>Name of the variable which is counted in the loop.</p> <code>''</code> <code>limit</code> <code>str</code> <p>Integer for the upper limit.</p> <code>''</code> <code>parallel</code> <code>bool</code> <p>A boolean indicating if the loop is a parallel loop or not.</p> <code>False</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.loop.Loop","title":"<code>pfdl_scheduler.model.loop.Loop(statements=None, context=None)</code>  <code>dataclass</code>","text":"<p>The base class for the PFDL loops.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.parallel.Parallel","title":"<code>pfdl_scheduler.model.parallel.Parallel(task_calls=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Parallel statement in the PFDL.</p> <p>Each task within this instruction is executed in parallel with the calling task. When all parallel tasks are finished, the calling task continues its execution.</p> <p>Attributes:</p> Name Type Description <code>task_calls</code> <code>List[TaskCall]</code> <p>List of Task Calls in the Parallel statement.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>task_calls</code> <code>List[TaskCall]</code> <p>List of Task Calls in the Parallel statement.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.process.Process","title":"<code>pfdl_scheduler.model.process.Process(structs=None, tasks=None)</code>  <code>dataclass</code>","text":"<p>Represents a production process described in a PFDL file.</p> <p>A Process consists of multiple Structs and Tasks. A Process object gets created after the visitor traverses the syntax tree.</p> <p>Attributes:</p> Name Type Description <code>structs</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Struct names to the Struct objects.</p> <code>task</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Task names to the Task objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>structs</code> <code>Dict[str, Struct]</code> <p>A dict for mapping the Struct names to the Struct objects.</p> <code>None</code> <code>tasks</code> <code>Dict[str, Task]</code> <p>A dict for mapping the Task names to the Task objects.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.service.Service","title":"<code>pfdl_scheduler.model.service.Service(name='', input_parameters=None, output_parameters=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Service or Service Call in the PFDL.</p> <p>Represents a Service or Service Call in the langauge which can be mapped to a real service that can be executed.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the Service.</p> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the Service.</p> <code>output_parameters</code> <code>OrderedDict[str, Union[str, Array]]</code> <p>List of output parameters of the Service.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the Service.</p> <code>''</code> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the Service.</p> <code>None</code> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the Service.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.struct.Struct","title":"<code>pfdl_scheduler.model.struct.Struct(name='', attributes=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a Struct in the PFDL.</p> <p>Data container for Services and Taskcalls. Used both for Struct definitons and instantiated Structs.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the Struct.</p> <code>attributes</code> <code>Dict[str, Union[str, Array, Struct]]</code> <p>A dict which maps the attribute names to the defined type         or a value (if its a instantiated struct).</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the Struct.</p> <code>''</code> <code>attributes</code> <code>Dict[str, Union[str, Array, Struct]]</code> <p>A dict which maps the attribute names to the defined type         or a value (if its a instantiated struct).</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.struct.Struct.from_json","title":"<code>from_json(json_string, error_handler, struct_context)</code>  <code>classmethod</code>","text":"<p>Creates a Struct instance out of the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_string</code> <code>str</code> <p>A JSON string desribing the Struct.</p> required <code>error_handler</code> <code>ErrorHandler</code> <p>An ErrorHandler instance used for printing errors.</p> required <p>Returns:</p> Type Description <code>Struct</code> <p>The Struct which was created from the JSON string.</p>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.task_call.TaskCall","title":"<code>pfdl_scheduler.model.task_call.TaskCall(name='', input_parameters=None, output_parameters=None, context=None)</code>  <code>dataclass</code>","text":"<p>Represents a TaskCall in the PFDL.</p> <p>Provides information about the name and call parameters of a Task which is called within another Task.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>A string representing the name of the TaskCall.</p> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the TaskCall.</p> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the TaskCall.</p> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>A string representing the name of the TaskCall.</p> <code>''</code> <code>input_parameters</code> <code>List[Union[str, List[str], Struct]]</code> <p>List of input parameters of the TaskCall.</p> <code>None</code> <code>output_parameters</code> <code>Dict[str, Union[str, Array]]</code> <p>List of output parameters of the TaskCall.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/model_classes/#pfdl_scheduler.model.while_loop.WhileLoop","title":"<code>pfdl_scheduler.model.while_loop.WhileLoop(statements=None, expression=None, context=None)</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Loop</code></p> <p>Represents a While Loop in the PFDL.</p> <p>Loops until conditional statement (expression) is satisfied.</p> <p>Attributes:</p> Name Type Description <code>statements</code> <p>List of statements inside the loop body.</p> <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict.</p> <code>context</code> <code>Dict</code> <p>ANTLR context object of this class.</p> <code>context_dict</code> <code>Dict</code> <p>Maps other attributes with ANTLR context objects.</p> <p>Initialize the object.</p> <p>Parameters:</p> Name Type Description Default <code>statements</code> <code>List[Union[Service, TaskCall, Loop, Condition]]</code> <p>List of statements inside the loop body.</p> <code>None</code> <code>expression</code> <code>Dict</code> <p>Boolean expression in form of a dict.</p> <code>None</code> <code>context</code> <code>ParserRuleContext</code> <p>ANTLR context object of this class.</p> <code>None</code>"},{"location":"scheduler/scheduler_class/","title":"Scheduler Class","text":""},{"location":"scheduler/scheduler_class/#the-scheduler-class","title":"The Scheduler class","text":"<p>The PFDL scheduler is the interface between the PFDL core (model, petri net) and the outside world. If you want to receive the current state of the Production Order or push it further by sending status updates of the services you can register callback functions and fire events.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler","title":"<code>pfdl_scheduler.scheduler.Scheduler(pfdl_file_path, generate_test_ids=False, draw_petri_net=True, scheduler_id='', dashboard_host_address='')</code>","text":"<p>             Bases: <code>Subject</code></p> <p>Schedules Tasks of a given PFDL file.</p> <p>The scheduler comprises almost the complete execution of a production order including the parsing of the PFDL description, model creation and validation and execution of the petri net. It interacts with the execution engines and informs them about services or tasks which started or finished.</p> <p>This class implements the Observer pattern and serves as subject. Observers can be registered in the scheduler and receive updates (e.g. log entries, info about a new petri net img,..)</p> <p>Attributes:</p> Name Type Description <code>running</code> <code>bool</code> <p>A boolean that indicates whether the scheduler is running.</p> <code>pfdl_file_valid</code> <code>bool</code> <p>A boolean indicating whether the given PFDL file was valid.</p> <code>process</code> <code>Process</code> <p>The corresponding Process instance from the PFDL file.</p> <code>petri_net_generator</code> <code>PetriNetGenerator</code> <p>A PetriNetGenerator instance for generating the petri net.</p> <code>petri_net_logic</code> <code>PetriNetLogic</code> <p>A PetriNetLogic instance for execution of the petri net.</p> <code>task_callbacks</code> <code>TaskCallbacks</code> <p>TaskCallbacks instance which holds the registered callbacks.</p> <code>variable_access_function</code> <code>Callable[[str], str]</code> <p>The function which will be called when the scheduler needs a variable.</p> <code>loop_counters</code> <code>Dict[str, Dict[str, int]]</code> <p>A dict for mapping task ids to the current loop counter (counting loops).</p> <code>awaited_events</code> <code>List[Event]</code> <p>A list of awaited <code>Event</code>s. Only these events can be passed to the net.</p> <code>generate_test_ids</code> <code>bool</code> <p>Indicates whether test ids should be generated.</p> <code>test_id_counters</code> <code>List[int]</code> <p>A List consisting of counters for the test ids of tasks and services.</p> <code>observers</code> <code>List[Observer]</code> <p>List of <code>Observers</code> used to update them on a <code>notify</code> call.</p> <p>Initialize the object.</p> <p>If the given path leads to a valid PFDL file the parsing will be started. If no errors occur the model of the PFDL File will be transformed into a petri net and be drawn if the <code>draw_petri_net</code> flag is set. If <code>generate_test_ids</code> is set the ids of the called tasks and services will be an enumeration starting at 0.</p> <p>Parameters:</p> Name Type Description Default <code>pfdl_file_path</code> <code>str</code> <p>The path to the PFDL file.</p> required <code>generate_test_ids</code> <code>bool</code> <p>A boolean indicating whether test ids should be generated.</p> <code>False</code> <code>draw_petri_net</code> <code>bool</code> <p>A boolean indicating whether the petri net should be drawn.</p> <code>True</code> <code>scheduler_id</code> <code>str</code> <p>A unique ID to identify the Scheduer / Production Order</p> <code>''</code> <code>dashboard_host_address</code> <code>str</code> <p>The address of the Dashboard (if existing)</p> <code>''</code>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.start","title":"<code>start()</code>","text":"<p>Starts the scheduling process for the given PFDL file from the path.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the corresponding PFDL file was valid and the Scheduler could be started.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.fire_event","title":"<code>fire_event(event)</code>","text":"<p>Forwards the given Event to the PetriNetLogic instance.</p> <p>The given <code>Event</code> object will be passed to the petri net if it is an awaited event.</p> <p>Parameters:</p> Name Type Description Default <code>event</code> <code>Event</code> <p>An <code>Event</code> instance.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the event could be fired to the petri net (is an awaited event).</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.register_callback_service_started","title":"<code>register_callback_service_started(callback)</code>","text":"<p>Registers the given callback in the service_started list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ServiceAPI], Any]</code> <p>Function which will be invoked when a Service is started.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.register_callback_service_finished","title":"<code>register_callback_service_finished(callback)</code>","text":"<p>Registers the given callback in the service_finished list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[ServiceAPI], Any]</code> <p>Function which will be invoked when a Service is finished.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.register_callback_task_finished","title":"<code>register_callback_task_finished(callback)</code>","text":"<p>Registers the given callback in the task_finished list.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[TaskAPI], Any]</code> <p>Function which will be invoked when a Task is finished.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the callback was successfully registered.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduler.Scheduler.register_variable_access_function","title":"<code>register_variable_access_function(var_access_func)</code>","text":"<p>Registers the given callback as the variable acces function of the Scheduler.</p> <p>Parameters:</p> Name Type Description Default <code>var_access_func</code> <code>Callable[[str], str]</code> <p>The function which will be called when the scheduler needs a variable.</p> required"},{"location":"scheduler/scheduler_class/#scheduler-callbacks","title":"Scheduler Callbacks","text":"<p>This section is an introduction of how to use the schedulers callback functions.</p> <p>In general, the callback functions can be subdivided into two classes: The first contains callback functions that are used by the scheduler to communicate the start or the finish of a task or service respectively: </p> <p>The task started callback creates an object of this task inside the EE. The required information to create this object are inside the TASK API object that is provided by the scheduler. Most important for this callback are the task\u2019s input variables. As tasks are nested inside other tasks, each new task object is a new level where local variables can be defined. The input variables that have to be part of the new task object are provided by the task_api.task_call.input_parameters object. New tasks can rename their input. The corresponding input values are provided in two different ways. First, variables can be transmitted to the new task object based on a variable inside the task_context. The second case describes the introduction of a new variable based on a literal structure definition inside the pfdl file. In this case, the variable\u2019s value is provided by the task_api.task_call.input_parameters object. </p> <p>Similar to the task started callback function, the task finished callback is used to update the task objects in the data lifecycle object. However, the task finished callback deletes them. In this case, variables in the task context object are either updated or added. The corresponding variables and values are provided that are returned from the task object can be extracted from the task_api.task.output_parameters object. The corresponding variable names are stored inside the task_api.task_call.output_parameters object. </p> <p>The service started callback leads to a service execution on the field level. In this connection, the PFDL scheduler schedules one service. Its input variables can be accessed through the service.service.input_parameters object. Here, it is either possible to use literal input values from the PFDL file, or use existing variables from the task object to parameterize the service. To identify the task object from which the variables values have to be queried, each service provides a service context object that identifies the task object in which context the service is executed. Services are never added to the data lifecycle object; however, their execution can be illustrated by providing, e.g. a state variable to mirror the execution\u2019s state and a service execution variable to specify the currently executed service. </p> <p>As Services possess output variables, the Service finished callback function is used to either update existing variables in the task object or to add new ones. Equally to the service started callback, the service finished callback provides a service.task_context.uuid object to identify the task object that has to be adjusted. </p> <p>The second class contains two callback functions that are used by the scheduler to access information from the EE. The first of these functions places tokens inside the petri net as soon as a service execution is completed. The second delivers a structure variable from the Data Lifecycle Object to the scheduler. This callback is required by the scheduler to access runtime data and thus, enables the scheduler to execute PFDL condition blocks. In this context, the scheduler always receives the complete structure and accesses single structure fields by itself. To identify the structure in the Data Lifecycle Object, the scheduler provides the tasks uuid, the task_contexts uuid and the variable name.  </p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduling.event.Event","title":"<code>pfdl_scheduler.scheduling.event.Event(event_type='', data=None)</code>","text":"<p>Data class for controlling the PetriNet instance.</p> Currently avaiable Events <ul> <li>Event(event_type=\"service_finished\", data={\"service_id\": }) <p>Attributes:</p> Name Type Description <code>event_type</code> <code>str</code> <p>A string representing the type of the event.</p> <code>data</code> <code>Dict</code> <p>A dict containing the corresponding data of the event type.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduling.event.Event.from_json","title":"<code>from_json(json_string)</code>  <code>classmethod</code>","text":"<p>Creates an Event instance out of the given JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>json_string</code> <code>str</code> <p>A JSON string desribing the Event.</p> required <p>Returns:</p> Type Description <code>Union[None, Event]</code> <p>The Event which was created from the JSON string. None if the conversion failed.</p>"},{"location":"scheduler/scheduler_class/#pfdl_scheduler.scheduling.task_callbacks.TaskCallbacks","title":"<code>pfdl_scheduler.scheduling.task_callbacks.TaskCallbacks()</code>  <code>dataclass</code>","text":"<p>Contains lists of callback functions that where registered in the scheduler.</p> <p>Attributes:</p> Name Type Description <code>task_started</code> <code>List[Callable[[TaskAPI], Any]]</code> <p>A list of callback functions which get called when a task is started.</p> <code>service_started</code> <code>List[Callable[[ServiceAPI], Any]]</code> <p>A list of callback functions which get called when a service is started.</p> <code>service_finished</code> <code>List[Callable[[ServiceAPI], Any]]</code> <p>A list of callback functions which get called when a service is finished.</p> <code>task_finished</code> <code>List[Callable[[TaskAPI], Any]]</code> <p>A list of callback functions which get called when a task is finished.</p> <p>Initialize the object.</p>"}]}